
; ===========================================================================
; =     Projekt      : CCBASIC ROM-Listing                                  =
; =     Version      : 07.08.1999.02.00 - 26.11.1999.09:28                  =
; =     Made by      : Dietmar Harlos, ADPC                                 =
; =     Status       : fertig kommentiert (ausser einige BASIC-Routinen)    =
; =     ROM-Version  : CCTRL-BASIC Version 1.1 (20.12.96)                   =
; =     ROM-Copyright: (C) 1996, Conrad Electronic GmbH Germany             =
; =                    Martin Foerster, CTC                                 =
; =     Assembler    : AS05.EXE (as05_111.zip) from Kingswood Software      =
; =     Disassembler : IDI05.EXE from Dietmar Harlos, ADPC                  =
; ===========================================================================

; Dieses Listing basiert auf dem Speicherinhalt des ROMs eines C-
; Control/BASIC-Mikrokontrollers. Alle Speicherbereiche, die Maschinencode
; enthalten, wurden disassembliert und alle Prozeduren (Subroutinen) durch
; einen Kommentarheader gekennzeichnet. Speicherbereiche mit Daten wurden,
; soweit das Sinn machte, zu Tabellen zusammengefasst und ebenfalls
; kommentiert.

; Im Kommentarheader jeder Betriebssystemsubroutine ist beschrieben, welche
; Aufgaben die jeweilige Routine erfuellt. Soweit noetig, wurden auch
; einfache Skizzen und einige Hinweise in den Header eingefuegt. Um die
; Routinen in eigenen Assemblerprogramme nutzen zu koennen ist im Header
; vermerkt, welche Parameter beim Aufruf uebergeben werden muessen oder
; zurueckgeliefert werden. Dabei stehen in eckigen Klammern ([]) alle
; Betriebssystemressourcen, auf die zwar zugegriffen wird, um die sich der
; Aufrufer aber nicht unbedingt zu kuemmern braucht (z.B. Ein- und Ausgaben
; von Ports, Daten aus dem EEPROM, o.ae.). Zusaetzlich sind im
; Kommentarheader unter der Sektion "used" alle Speicherstellen und Register
; aufgefuehrt, die sich durch Aufruf der Subroutine veraendern koennen. Unter
; "called from" ist schliesslich angegeben, von welchem Punkt im ROM aus die
; entsprechende Unterroutine angesprungen wird. Dadurch ist es moeglich, den
; Programmfluss zurueckzuverfolgen.

; Bei den Input-, Output- und Used-Sektionen ist zu beachten, dass
; Speicheradressen auf die ueber das Index Register oder ueber die Pseudo-
; Adressierungscodes zugegriffen wird, im allgemeinen nicht aufgefuehrt sind.
; Das wird sich aber eventuell in einer der naechsten Ausgaben dieses ROM-
; Listings aendern.

; Fuer die BASIC-Hauptroutinen der verschiedenen CCBASIC-Befehle (Token)
; gilt, dass alle mehr als ein Byte langen Befehle zusaetzliche Daten aus dem
; EEPROM holen (folgen im EEPROM nach dem BASIC-Token). Die Buchstaben, die
; hinter dem Token im Kommentarheader der jeweiligen Routine stehen, dienen
; als Platzhalter fuer folgende Datengroessen: b=Bytewert, w=Wordwert und
; s=nullterminierter String. Die anderen BASIC-Befehle holen ihre benoetigten
; Daten entweder eigenstaendig vom Rechenstack oder aber brauchen keinen
; Input. Zur Rueckgabe von Rechenergebnisse wird, bis auf einige wenige
; Ausnahmen, ebenfalls der Stack benutzt.

; Auf eine ausgiebige Beschreibung der meisten BASIC-Hauptroutinen wurde
; verzichtet, da diese im Originalquellcode zum Betriebssystem weitaus
; leichter als in diesem ROM-Listing zu verstehen sind. Ausserdem werden die
; zugehoerigen Befehle bereits in der Bedienungsanleitung zur C-Control
; behandelt und so sollte es nicht schwer fallen, die Aufgaben dieser
; Routinen zu durchschauen. Eine Benutzung der BASIC-Hauptroutinen innerhalb
; eines Assemblerprogramme macht ohnehin meist keinen Sinn, da diese
; zusaetzliche Daten aus dem EEPROM lesen und/oder Daten vom Stack lesen oder
; auf diesen schreiben. Dagegen sind die meisten Unterroutinen der BASIC-
; Befehle sehr leicht und effektiv nutzbar und wurden darum auch recht
; ausfuehrlich kommentiert.

; Auf eine Uebernahme der Symbolnamen fuer Datenadressen und Subroutinen, die
; im von Conrad Electronic veroeffentlichten Originalquellcode des
; Betriebssystems Verwendung fanden, wurde zugunsten einer ausfuehrlicheren
; Dokumentation und Umschreibung der jeweiligen Speicherstellen verzichtet.
; Ich denke, diese Umschreibung (in der Datei ADRESSEN.TXT) ist weitaus
; aussagekraeftiger als die reinen Symbolnamen.

; Wer zusaetzliche Informationen darueber benoetigt, auf was innerhalb einer
; Subroutine lesend und schreibend zugegriffen wird, muss sich mit dem
; Disassembler IDI05 ein eigenes ROM-Listing erstellen. Dazu muss einfach die
; Batch-Datei BEISPIEL.BAT im Verzeichnis DISASSEM gestartet werden.

; In diesem ROM-Listing wurden im Kommentartext Werte und Adressen in der
; gleichen Weise gekennzeichnet, wie in der Mnemonic zur 6805'er
; Assemblersprache allgemein ueblich. Ein Doppelkreuz (#) vor einer Zahl
; kennzeichnet einen Wert, waehrend eine reine Zahl, aehnlich den Variablen
; von Hochsprachen, den Inhalt einer Adresse symbolisiert (Beispiel: $50 ->
; Inhalt der Adresse $50). Ein Dollarzeichen ($) vor einer Zahl kennzeichnet
; diese als Hexadezimalzahl. Da an vielen Stellen im Betriebssystem zwei
; aufeinanderfolgende Speicherstellen zum Speichern von 16-Bit-Werten
; ("Words") benutzt werden, habe ich diese mit einem Doppelpunkt
; zusammengefasst. So symbolisiert z.B. $50:$51 den Inhalt eines Words,
; dessen Highbyte auf Adresse $50 und dessen Lowbyte auf Adresse $51 steht.

; In den Zeilen jeden Befehls, auf den ueber einen Sprungbefehl (jmp, jsr,
; bsr, bra, bxx) zugegriffen wird, steht in der sechsten Spalte ein Doppel-
; punkt. Dadurch koennen vor allem "Near"-Sprungziele recht schnell gefunden
; werden.

; DAS ROM-LISTING:
; ================

; Ab hier folgt nun endlich das eigentliche ROM-Listing. Es kann einerseits
; dazu benutzt werden, um die Vorgaenge im Betriebssystem zu verstehen, um
; die 6805-Assemblersprache zu erlernen oder um Adressen von Daten und
; Subroutinen herauszufinden. Zum leichteren Verstaendnis sollten die Dateien
; INFO.TXT, ADRESSEN.TXT, BEFEHLE.TXT, BUGS.TXT, CCBASTOK.TXT, DCF77.TXT,
; I2C.TXT, INTERRUP.TXT, MC68HC05.TXT und SYMBOLS.TXT ebenfalls gelesen
; werden. Ausserdem sollte moeglichst das Manual zum MC68HC05B6 von Motorola
; und der Originalquellcode des in der Programmiersprache C entwickelten
; Betriebssystems vorliegen.

; Als Startpunkte fuer die Erkundung des Betriebsssystem empfehle ich die
; Sprungtabelle am Ende des ROMs. Dort sind alle Adressen der Routinen
; aufgefuehrt, die bei einem Interrupt aufgerufen werden.

              noopt
              org $200

; ***************************************************************************
; **                                                                       **
; **   Self-Check-ROM I                                                    **
; **                                                                       **
; **   Die Routine $200 liegt vor dem eigentlichen, maskenprogrammierten   **
; **   Betriebssystem  (das erst bei Adresse $800 beginnt). Bei der        **
; **   Routine handelt es sich um eine von Motorolaingenieuren entwickelte **
; **   Urloader-Routine fuer einen allgemeinen MC68HC05B6-Mikrokontroller. **
; **   Sie gehoert also nicht zum CCBASIC-Betriebssystem.                  **
; **                                                                       **
; **   Der MC68HC05B6 unterstuetzt besondere Operationsmodi, mit denen ein **
; **   Maschinenspracheprogramm zum Mikrokontroller uebertragen und aus-   **
; **   gefuehrt werden kann. Dazu muss nach einem Reset eine der folgenden **
; **   Bedingungen erfuellt sein:                                          **
; **                                                                       **
; **      IRQ         TCAP1      SEC  PB3  PB4   Funktion                  **
; **                                                                       **
; **  VSS bis VDD  VSS bis VDD    X    X    X    Normaler Modus            **
; **    2 * VDD        VDD        1   VSS  VSS   Serial RAM loader         **
; **    2 * VDD        VDD        1   VSS  VDD   Serial RAM loader         **
; **    2 * VDD        VDD        1   VDD  VSS   Progr. ueber PORTA lesen  **
; **    2 * VDD        VDD        1   VDD  VDD   Jump to any address       **
; **    2 * VDD        VDD        0   VSS  VSS   EEPROM und RAM loeschen,  **
; **                                             Progr. ueber PORTA lesen  **
; **    2 * VDD        VDD        0   VSS  VDD   EEPROM und RAM loeschen,  **
; **                                             Progr. ueber PORTA lesen  **
; **    2 * VDD        VDD        0   VDD  VSS   EEPROM und RAM loeschen,  **
; **                                             Serial RAM loader         **
; **    2 * VDD        VDD        0   VDD  VDD   EEPROM und RAM loeschen,  **
; **                                             Serial RAM loader         **
; **                                                                       **
; **   Die Werte fuer SEC, PB3 und PB4 wurden aus dem disassemblierten     **
; **   Self-Check-ROM-I-Listing gewonnen und sind ohne Gewaehr.            **
; **   Naehere Informationen sollten dem MC68HC05B6-Manual von der Firma   **
; **   Motorola entnommen werden. Es ist im Internet frei erhaeltlich.     **
; **                                                                       **
; ***************************************************************************

; ---------------------------------------------------------------------------
;      Self-Check-ROM I
;
;      used  : a,x,$0(%00000001),$4(%00000001),$7,$7(%00000001),$d-$e,
;              $f(%00000100),$13,$16-$17,$19,$50,$53
;
;      called from $1fee (?)
; ---------------------------------------------------------------------------

0200 : a601   lda #$01            ; ist das SEC-Bit gesetzt?
0202   c40100 and $0100           ;
0205   270a   beq $0211           ; falls nein, dann EEPROM & RAM loeschen
0207   b603   lda $03             ;
0209   a818   eor #$18            ; sind PD3 und PD4 gesetzt?
020b   a418   and #$18            ;
020d   263e   bne $024d           ; falls nein, dann springe

; ---------------------------------------------------------------------------
;      Jump to any address
; ---------------------------------------------------------------------------

020f   bc00   jmp $00             ; PORTA,B,C enthalten Maschinencodeprogramm

; ---------------------------------------------------------------------------
;      EEPROM und RAM loeschen
; ---------------------------------------------------------------------------

0211 : b603   lda $03             ; Inhalt von PORTD nach $50 kopieren
0213   b750   sta $50             ;
0215   201a   bra $0231           ; branch always to $0231

0217 : a606   lda #$06            ; E1LAT und E1ERA setzen
0219   b707   sta $07             ;
021b   d70100 sta $0100,x         ; auf Adresse $0100 + x zugreifen
021e   a627   lda #$27            ; a = #$27
0220   1007   bset #0,$07         ; E1PGM setzen
0222   b719   sta $19             ; TRLOW = a
0224   b716   sta $16             ; OCR1HIGH = a
0226   b713   sta $13             ; TOF setzen
0228   a610   lda #$10            ; a = #$10
022a   b717   sta $17             ; OCR1LOW = a
022c : 0d13fd brclr #6,$13,$022c  ; warte, bis OCF1 gesetzt ist
022f   3f07   clr $07             ; E1LAT loeschen

0231 : 5f     clrx                ; ist irgendein EEPROM-Byte ungleich
0232 : 5a     decx                ;   #$ff (sprich: nicht geloescht)?
0233   d60100 lda $0100,x         ;
0236   4c     inca                ;
0237   26de   bne $0217           ; falls ja, Byte loeschen
0239   5d     tstx                ;
023a   26f6   bne $0232           ; weitersuchen

023c   ae51   ldx #$51            ; alle Bytes von Adresse $51 bis $ff
023e : ff     stx ,x              ;   ueberschreiben (RAM loeschen)
023f   5c     incx                ;
0240   26fc   bne $023e           ;

0242   ae50   ldx #$50            ; Verzoegerungsschleife
0244 : 9d     nop                 ;
0245   9d     nop                 ;
0246   9d     nop                 ;
0247   5c     incx                ;
0248   26fa   bne $0244           ;

024a   b650   lda $50             ; a = alter PORTD-Zustand
024c   43     coma                ; Akku invertieren

024d : a408   and #$08            ; ist PD3 gesetzt?
024f   2619   bne $026a           ; falls ja, dann Programm ueber PORTA holen

; ---------------------------------------------------------------------------
;      Serial RAM loader
; ---------------------------------------------------------------------------

0251   a6c0   lda #$c0            ; Baudrate auf 9600 Baud setzen
0253   b70d   sta $0d             ;
0255   3f0e   clr $0e             ; SCCR1 loeschen
0257   140f   bset #2,$0f         ; RE setzen
0259   ae50   ldx #$50            ; x = #$50
025b : 0b10fd brclr #5,$10,$025b  ; warte, bis ein Byte empfangen wurde
025e   b611   lda $11             ; a = empfangenes Byte
0260   f7     sta ,x              ; empfangenes Byte auf Adresse x speichern
0261   3a50   dec $50             ; Anzahl der zu empfangenen Bytes dekrement.
0263   2703   beq $0268           ; falls null, dann springen
0265   5c     incx                ; x-Register inkrementieren
0266   26f3   bne $025b           ; weitermachen, wenn x <= #$ff ist
0268 : bc51   jmp $51             ; in das empfangene Programm springen

; ---------------------------------------------------------------------------
;      Vier Byte seriell ueber Pin 0 von PORTA empfangen, die ersten drei
;      Byte ab RAM-Adresse $50 und das letzte Byte im Akku speichern. Dann
;      die Adresse $50 als Maschinenspracheprogramm aufrufen und anschlie-
;      ssend den Akku-Inhalt ueber Pin 0 von PORTA ausgeben
;      (diese Funktion ist im Manual von Motorola nicht dokumentiert)
; ---------------------------------------------------------------------------

026a : 1104   bclr #0,$04         ; Pin 0 von PORTA als Eingang schalten
026c   ae50   ldx #$50            ; x = #$50
026e : 0000fd brset #0,$00,$026e  ; warte, bis Pin 0 von PORTA low ist
0271   a632   lda #$32            ; Verzoegerungsschleife
0273 : 4a     deca                ;
0274   26fd   bne $0273           ;
0276   a680   lda #$80            ; a = #$80
0278   f7     sta ,x              ; a auf Adresse x speichern
0279 : 010000 brclr #0,$00,$027c  ; Carry Bit setzen, wenn PA0 gesetzt ist
027c : a620   lda #$20            ; Verzoegerungsschleife
027e : 4a     deca                ;
027f   26fd   bne $027e           ;
0281   76     ror ,x              ; Carry Bit auf Adresse x speichern
0282   24f5   bcc $0279           ; weitermachen, bis alle 8 Bits empfangen
0284   0100e3 brclr #0,$00,$026a  ; neu starten, wenn PA0 nicht gesetzt ist
0287   f6     lda ,x              ; Akku mit Wert von Adresse x laden
0288   5c     incx                ; Index Register inkrementieren
0289   a354   cmpx #$54           ; ist das Index Register gleich #$54?
028b   26e1   bne $026e           ; falls nein, weitermachen

028d   ae81   ldx #$81            ; 'rts' auf Adresse $53 speichern
028f   bf53   stx $53             ;
0291 : 5c     incx                ; Verzoegerungsschleife
0292   26fd   bne $0291           ;
0294   bd50   jsr $50             ; in das empfangene Programm springen

0296   99     sec                 ; Carry Bit setzen
0297   1004   bset #0,$04         ; Pin 0 von PORTA auf Ausgang schalten
0299 : 1100   bclr #0,$00         ; Pin 0 von PORTA low setzen
029b : ae20   ldx #$20            ; Verzoegerungsschleife
029d : 5a     decx                ;
029e   26fd   bne $029d           ;
02a0   46     rora                ; solange weitermachen, bis ein Bit im
02a1   24f6   bcc $0299           ;   Akku gesetzt ist
02a3   98     clc                 ; Carry Bit loeschen
02a4   1000   bset #0,$00         ; Pin 0 von PORTA high setzen
02a6   26f3   bne $029b           ; weitermachen, bis Akku uebertragen wurde

02a8   20c0   bra $026a           ; und das ganze noch einmal

; ---------------------------------------------------------------------------
;      Der Bereich von Adresse $2aa bis $7ff ist unbelegt.
; ---------------------------------------------------------------------------

              org $800

; ***************************************************************************
; **                                                                       **
; **   CCBASIC-BETRIEBSSYSTEM                                              **
; **                                                                       **
; **   Ab Adresse $800 beginnt das eigentliche, von Conrad Electronic      **
; **   entwickelte, Betriebssystem des C-Control/BASIC-Chips. Am Ende des  **
; **   Speichers (ab Adresse $1ff2) stehen die Startadressen der           **
; **   diversen Interruptroutinen. Bei einem Reset wird beispielsweise     **
; **   zur Adresse $1d12, und von dort aus direkt zum Anfang des           **
; **   Betriebssystems (Adresse $800) gesprungen.                          **
; **                                                                       **
; ***************************************************************************

; ---------------------------------------------------------------------------
;      Initialisierung nach RESET, zur IDLE-LOOP springen
;      jumped from $1d12
; ---------------------------------------------------------------------------

0800 : 9c     rsp                 ; Stack Pointer resetten (SP=$FF)
0801   ae5a   ldx #$5a            ;
0803 : a3d9   cmpx #$d9           ; Speicher von $5a bis $d8 loeschen
0805   2704   beq $080b           ;
0807   7f     clr ,x              ;
0808   5c     incx                ;
0809   20f8   bra $0803           ;

080b : cd1d06 jsr $1d06           ;'lda adr16' und 'rts' auf Adresse $dd
080e   cc0940 jmp $0940           ; springe zur Initialierung der IDLE-LOOP

; ---------------------------------------------------------------------------
;      nach Reset I2C-Bus initialisieren
;      dient vermutlich dazu eine Datenuebertragung abzuschliessen,
;      falls der Mikrokontroller mitten in einer Uebertragung resettet
;      wurde
;      nach dem Aufruf dieser Routine ist SCL und SDA HIGH
;
;      Signalverlauf auf den beiden Leitungen durch diese Routine:
;
;                 _________________________        --- = undefiniert
;      SDA  ------                                 ___ = low (0 Volt)
;                  _ _ _ _ _ _ _ _ ________        ___
;      SCL  -----__ _ _ _ _ _ _ _ _                    = high (5 Volt)
;
;
;      input : -
;      output: -
;      used  : $0(%00000011),$4(%00000011)
;
;      called from $0951
; ---------------------------------------------------------------------------

0811 : 1204   bset #1,$04         ; Pin1 (SCL) von PORTA als Ausgang schalten
0813   1300   bclr #1,$00         ; SCL low (0 Volt)
0815   1004   bset #0,$04         ; Pin0 (SDA) von PORTA als Ausgang schalten
0817   1000   bset #0,$00         ; SDA high (5 Volt)
0819   1200   bset #1,$00         ; SCL high (5 Volt)
081b   1300   bclr #1,$00         ; SCL low (0 Volt)
081d   1200   bset #1,$00         ; SCL high (5 Volt)
081f   1300   bclr #1,$00         ; SCL low (0 Volt)
0821   1200   bset #1,$00         ; SCL high (5 Volt)
0823   1300   bclr #1,$00         ; SCL low (0 Volt)
0825   1200   bset #1,$00         ; SCL high (5 Volt)
0827   1300   bclr #1,$00         ; SCL low (0 Volt)
0829   1200   bset #1,$00         ; SCL high (5 Volt)
082b   1300   bclr #1,$00         ; SCL low (0 Volt)
082d   1200   bset #1,$00         ; SCL high (5 Volt)
082f   1300   bclr #1,$00         ; SCL low (0 Volt)
0831   1200   bset #1,$00         ; SCL high (5 Volt)
0833   1300   bclr #1,$00         ; SCL low (0 Volt)
0835   1200   bset #1,$00         ; SCL high (5 Volt)
0837   1300   bclr #1,$00         ; SCL low (0 Volt)
0839   1200   bset #1,$00         ; SCL high (5 Volt)
083b   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Uebertrage ein Byte ueber den I2C-Bus zum externen EEPROM,
;      beginnend mit einem START-Impuls
;      falls das EEPROM kein ACK sendet wird das Byte noch einmal, wiederum
;      beginnend mit einem START-Impuls, uebertragen
;      nach dem Aufruf dieser Routine ist SCL LOW und SDA HIGH
;              __
;      SDA  ---  ____...
;               __
;      SCL  ----  ___...
;
;      input : x=Byte
;      output: -
;      used  : a,x,$0(%00000011),$4(%00000001),$e1
;
;      called from $086d,$0d96,$0dbd,$0def,$0dfe
; ---------------------------------------------------------------------------

083c : 1004   bset #0,$04         ; Pin1 (SDA) von PORTA als Ausgang schalten
083e   1000   bset #0,$00         ; SDA high
0840   1200   bset #1,$00         ; SCL high
0842   1100   bclr #0,$00         ; SDA low
0844   1300   bclr #1,$00         ; SCL low

; ---------------------------------------------------------------------------
;      Uebertrage ein Byte ueber den I2C-Bus zum externen EEPROM
;      falls das EEPROM kein ACK sendet wird das Byte noch einmal, diesmal
;      beginnend mit einem START-Impuls, uebertragen
;      nach dem Aufruf dieser Routine ist SCL LOW und SDA HIGH
;
;      input : x=Byte
;      output: -
;      used  : a,x,$0(%00000011),$4(%00000001),$e1
;
;      called from $0d9b,$0da0,$0da5,$0dc2,$0dc7,$0dcc,$0dd1,$0df4,$0df9
; ---------------------------------------------------------------------------

0846 : 1004   bset #0,$04         ; Pin0 (SDA) von PORTA als Ausgang schalten
0848   9f     txa                 ; a=x
0849   c700e1 sta >$00e1          ; Akkumulator auf $e1 zwischenspeichern
084c   ae08   ldx #$08            ; Schleifenzaehler fuer 8 Bits
084e : 49     rola                ; es wird mit dem MSB gestartet
084f   2404   bcc $0855           ; ist das Bit gesetzt?
0851   1000   bset #0,$00         ; falls ja, SDA high setzen
0853   2002   bra $0857           ; und ueberspringen
0855 : 1100   bclr #0,$00         ; falls nein, SDA low setzen
0857 : 1200   bset #1,$00         ; und ein kurzer Impuls auf
0859   1300   bclr #1,$00         ;   der SCL-Leitung
085b   5a     decx                ; weitermachen,
085c   26f0   bne $084e           ;   bis ein Byte uebertragen wurde

085e   1104   bclr #0,$04         ; Pin0 (SDA) von PORTA als Eingang schalten
0860   1200   bset #1,$00         ; SCL high setzen
0862   000003 brset #0,$00,$0868  ; falls kein ACK gesetzt ist -> Fehler
0865   1300   bclr #1,$00         ; SCL wieder low
0867   81     rts                 ; return from subroutine

0868 : 1300   bclr #1,$00         ; SCL wieder low
086a   ce00e1 ldx >$00e1          ; falls EEPROM nicht bereit war wird das
086d   20cd   bra $083c           ; Byte noch einmal uebertragen

; ---------------------------------------------------------------------------
;      Hole ein Byte aus dem externen, seriellen EEPROM
;      nach dem Aufruf dieser Routine ist SCL und SDA LOW
;
;      Laut Spezifikation im 24C65-Manual benoetigt das EEPROM im Fastmode
;      nach einem SCL-Impuls mindestens 1.2 æs zum Anlegen eines neuen
;      Bits. Die Zeit die der Kontroller dem EEPROM laesst (max. 1.5 æs)
;      ist also reichlich knapp bemessen. Besser waere es, wenn vor jedem
;      "ldx $00" ein "nop" stehen wuerde. Jetzt koennten u.U. ein paar
;      Highbits als Lowbits erkannt werden, denn zum jetzigen Lesezeitpunkt
;      liegt die Ausgangsspannung des EEPROMs bei knapp 70% von VDD, was
;      der Mikrokontroller laut Manual gerade eben als Highzustand erkennt.
;
;      input : -
;      output: a=Byte
;      used  : a,x,$0(%00000011),$4(%00000001)
;
;      jumped from $0e0a
; ---------------------------------------------------------------------------

086f : 1104   bclr #0,$04         ; SDA als Eingang schalten
0871   4f     clra                ; a = #0
0872   be00   ldx $00             ; SDA ist Bit 0 von Port A
0874   56     rorx                ; SDA von rechts (nach links) in
0875   49     rola                ;   den Akku schieben -> erstes Bit gelesen
0876   1200   bset #1,$00         ; und ein kurzer Impuls auf der
0878   1300   bclr #1,$00         ;   SCL-Leitung
087a   be00   ldx $00             ;
087c   56     rorx                ; zweites Bit lesen
087d   49     rola                ;
087e   1200   bset #1,$00         ; und ein kurzer Impuls auf der
0880   1300   bclr #1,$00         ;   SCL-Leitung
0882   be00   ldx $00             ;
0884   56     rorx                ; drittes Bit lesen
0885   49     rola                ;
0886   1200   bset #1,$00         ; und ein kurzer Impuls auf der
0888   1300   bclr #1,$00         ;   SCL-Leitung
088a   be00   ldx $00             ;
088c   56     rorx                ; viertes Bit lesen
088d   49     rola                ;
088e   1200   bset #1,$00         ; und ein kurzer Impuls auf der
0890   1300   bclr #1,$00         ;   SCL-Leitung
0892   be00   ldx $00             ;
0894   56     rorx                ; fuenftes Bit lesen
0895   49     rola                ;
0896   1200   bset #1,$00         ; und ein kurzer Impuls auf der
0898   1300   bclr #1,$00         ;   SCL-Leitung
089a   be00   ldx $00             ;
089c   56     rorx                ; sechstes Bit lesen
089d   49     rola                ;
089e   1200   bset #1,$00         ; und ein kurzer Impuls auf der
08a0   1300   bclr #1,$00         ;   SCL-Leitung
08a2   be00   ldx $00             ;
08a4   56     rorx                ; siebtes Bit lesen
08a5   49     rola                ;
08a6   1200   bset #1,$00         ; und ein kurzer Impuls auf der
08a8   1300   bclr #1,$00         ;   SCL-Leitung
08aa   be00   ldx $00             ;
08ac   56     rorx                ; achtes Bit lesen
08ad   49     rola                ;
08ae   1200   bset #1,$00         ; und ein kurzer Impuls auf der
08b0   1300   bclr #1,$00         ;   SCL-Leitung
08b2   1004   bset #0,$04         ; SDA auf Ausgang schalten
08b4   1100   bclr #0,$00         ; und SDA low (als ACK-Signal)
08b6   1200   bset #1,$00         ; und ein kurzer Impuls auf der
08b8   1300   bclr #1,$00         ;   SCL-Leitung
08ba   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Sequentielles Lesen vom EEPROM beenden
;      es wird ein Byte vom EEPROM gelesen und verworfen, ACK nicht
;      gesetzt und ein STOP-Impuls uebertragen
;      nach dem Aufruf dieser Routine ist SCL und SDA HIGH
;
;      fuer das 24C65-EEPROM bedeutet ein nicht gesetztes ACK-Signal
;      bei der Uebertragung vom EEPROM zum Master, dass das sequentielle
;      Senden beendet werden soll
;
;      input : -
;      output: -
;      used  : $0(%00000011),$4(%00000001)
;
;      jumped from $0e01
; ---------------------------------------------------------------------------

08bb : 1104   bclr #0,$04         ; Pin0 (SDA) von PORTA als Eingang schalten
08bd   1200   bset #1,$00         ; SCL high
08bf   1300   bclr #1,$00         ; SCL low
08c1   1200   bset #1,$00         ; SCL high
08c3   1300   bclr #1,$00         ; SCL low
08c5   1200   bset #1,$00         ; SCL high
08c7   1300   bclr #1,$00         ; SCL low
08c9   1200   bset #1,$00         ; SCL high
08cb   1300   bclr #1,$00         ; SCL low
08cd   1200   bset #1,$00         ; SCL high
08cf   1300   bclr #1,$00         ; SCL low
08d1   1200   bset #1,$00         ; SCL high
08d3   1300   bclr #1,$00         ; SCL low
08d5   1200   bset #1,$00         ; SCL high
08d7   1300   bclr #1,$00         ; SCL low
08d9   1200   bset #1,$00         ; SCL high
08db   1300   bclr #1,$00         ; SCL low
08dd   1004   bset #0,$04         ; Pin0 (SDA) von PORTA als Ausgang schalten
08df   1000   bset #0,$00         ; SDA high, (einzige Unterschied zu $086f)
08e1   1200   bset #1,$00         ; SCL high
08e3   1300   bclr #1,$00         ; SCL low

; ---------------------------------------------------------------------------
;      STOP-Signal zum EEPROM senden
;      hiermit wird die Uebertragung eines Datenblocks beendet, der I2C-
;      Bus geht in den Ruhezustand, erneuter Start nur mit einem START-
;      Impuls moeglich
;      nach dem Aufruf dieser Routine ist SCL und SDA HIGH
;                ___
;      SDA  ---__
;               ____
;      SCL  ----
;
;      input : -
;      output: -
;      used  : $0(%00000011),$4(%00000001)
;
;      called from $0da8,$0dd4
; ---------------------------------------------------------------------------

08e5 : 1004   bset #0,$04         ; Pin0 (SDA) von PORTA als Ausgang schalten
08e7   1100   bclr #0,$00         ; SDA low
08e9   1200   bset #1,$00         ; SCL high
08eb   1000   bset #0,$00         ; SDA high
08ed   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      BASIC-Programm starten und ausfuehren
;
;      input : -
;      output: -
;      used  : a,x,$0(%01001111),$4(%00000001),$5a,$66-$67,$7b(%11000010),
;              $bb-$bc,$d3-$d4,$dd,$dd(%00001011),$de-$df,$e1
;
;      called from $097b
; ---------------------------------------------------------------------------

08ee : 1700   bclr #3,$00         ; ACTIVE-LED einschalten
08f0   1500   bclr #2,$00         ; RUN-LED einschalten
08f2   127b   bset #1,$7b         ; Marker fuer BASIC-Programmausfuehrung
08f4   5f     clrx                ;
08f5   a604   lda #$04            ; BASIC-Programmcounter des Mikro-
08f7   b7d4   sta $d4             ; kontrollers und den Adresszaehler
08f9   bfd3   stx $d3             ; des EEPROMs mit #$0004 laden
08fb   cd0de5 jsr $0de5           ;
08fe   1d7b   bclr #6,$7b         ; Marker fuer BASIC-IRQ-Interrupt loeschen

0900 : 0d7b0b brclr #6,$7b,$090e  ; fand ein BASIC-IRQ-Interrupt statt?
0903   b6bb   lda $bb             ; falls ja, pruefen ob die BASIC-IRQ-
0905   babc   ora $bc             ;   Routine bereits ausgefuehrt wird
0907   2605   bne $090e           ; falls ja, BASIC-IRQ-Routine nicht starten
0909   1d7b   bclr #6,$7b         ; falls nein, BASIC-IRQ-Marker loeschen
090b   cd19ee jsr $19ee           ;   und die BASIC-IRQ-Unterroutine starten

090e : cd0e04 jsr $0e04           ; hole naechstes BASIC-Token in den Akku
0911   b75a   sta $5a             ; BASIC-Token auf Adresse $5a speichern
0913   a1ff   cmp #$ff            ; ist das geholte Token=255 (END-Befehl) ?
0915   260e   bne $0925           ; falls nicht, springe nach $925
0917 : cd0e01 jsr $0e01           ; sequentielles Lesen vom EEPROM beenden
091a   1600   bset #3,$00         ; ACTIVE-LED ausschalten
091c   1400   bset #2,$00         ; RUN-LED ausschalten
091e   137b   bclr #1,$7b         ; Marker fuer BASIC-Programmausfuehrung
0920   1f7b   bclr #7,$7b         ; Handshake-Bit (fuer RTS/CTS) loeschen
0922   1d00   bclr #6,$00         ; RTS auf 0 Volt setzen
0924   81     rts                 ; return from subroutine

0925 : a154   cmp #$54            ; ist das Token groesser als 84 ?
0927   22ee   bhi $0917           ; falls ja, beenden
0929   5f     clrx                ;
092a   48     lsla                ; Adresse der entsprechenden Routine
092b   59     rolx                ; zu dem BASIC-Token aus der Sprungtabelle
092c   abf6   add #$f6            ; holen und die Routine aufrufen
092e   b7df   sta $df             ;
0930   9f     txa                 ; die Sprungtabelle steht auf Adresse
0931   a91d   adc #$1d            ;   $1ddf im ROM
0933   b7de   sta $de             ;
0935   97     tax                 ; die Adresse der jeweiligen BASIC-Routine
0936   b6df   lda $df             ;   steht an Adresse $1ddf + 2*Token
0938   cd1ce3 jsr $1ce3           ;
093b   cd1cdb jsr $1cdb           ;
093e   20c0   bra $0900           ; weitermachen, bis END-Befehl

; ---------------------------------------------------------------------------
;      Initialisierung nach RESET und Ausfuehren der IDLE-LOOP
;      jumped from $080e
; ---------------------------------------------------------------------------

0940 : 9b     sei                 ; Interrupts verbieten
0941   4f     clra                ; Akkumulator loeschen
0942   c70050 sta >$0050          ; IRQPTR (Userpointer) loeschen
0945   c70051 sta >$0051          ; CAPPTR (Userpointer) loeschen
0948   c70052 sta >$0052          ; CMPPTR (Userpointer) loeschen
094b   c70053 sta >$0053          ; OFLPTR (Userpointer) loeschen
094e   cd0e18 jsr $0e18           ; Speicherbereiche und einige Ports init.
0951   cd0811 jsr $0811           ; EEPROM initialisieren
0954   cd0c63 jsr $0c63           ; RS232 Schnittstelle mit 9600 Baud init.
0957   3f7b   clr $7b             ; alle Bits im Statusbyte loeschen
0959   1604   bset #3,$04         ; ACTIVE-LED-Pin auf Ausgang schalten
095b   1404   bset #2,$04         ; RUN-LED-Pin auf Ausgang schalten
095d   cd11e1 jsr $11e1           ; loeschen der 24 Userbytes ab Adresse $A1
0960   cd116a jsr $116a           ; Rechenstack ($91..$9e) loeschen
0963   cd1596 jsr $1596           ; BASIC-RAM (fuer SYS, GOSUB, IRQ) init.
0966   1a0c   bset #5,$0c         ; IRQ bei negativer Flanke detektieren
0968   9a     cli                 ; Interrupts erlauben

; ---- BEGIN IDLE-LOOP ------------------------------------------------------
0969 : 8f     wait                ; auf einen Interrupt warten
096a   ae05   ldx #$05            ;
096c   c60000 lda >$0000          ; lade Datenbyte von PORTA und
096f : 44     lsra                ; schiebe es 5 Bits nach links, so das
0970   5a     decx                ; das START-Bit auf Bit 0 liegt
0971   26fc   bne $096f           ;
0973   a401   and #$01            ; teste Bit 0 (START-Bit)
0975   5d     tstx                ; falls nicht geloescht ist (PIN inaktiv),
0976   2608   bne $0980           ; nach RS232 schauen
0978   4d     tsta                ;
0979   2605   bne $0980           ; falls START-Bit geloescht ist,
097b   cd08ee jsr $08ee           ; das BASIC-Programm starten
097e   20e9   bra $0969           ; mache weiter mit der IDLE-LOOP

0980 : cd0cce jsr $0cce           ; liegt ein Byte an der RS232 an?
0983   4d     tsta                ; wenn nein, weiter mit IDLE-LOOP
0984   27e3   beq $0969           ; falls doch, Byte holen und als
0986   cd0aa4 jsr $0aa4           ; Befehlsbyte ausfuehren
0989   20de   bra $0969           ; mache weiter mit der IDLE-LOOP
; ---- END IDLE-LOOP --------------------------------------------------------

; ---------------------------------------------------------------------------
;      fuer BASIC Token 10 b - internes BASIC-Kommando
;      Bitport abfragen
;
;      input : x = Bitport-Nummer (0..15)
;      output: a = $54 = ist gleich der Wertigkeit des gesuchten Bits
;      used  : a,x,$54-$56
;
;      called from $1724
; ---------------------------------------------------------------------------

098b : 9f     txa                 ; a = x
098c   44     lsra                ; a = a \ #8
098d   44     lsra                ; (falls a groesser #7 war, ist a jetzt #1
098e   44     lsra                ;    sonst ist a gleich #0)
098f   b756   sta $56             ; nach $56 retten
0991   9f     txa                 ; a = x
0992   a407   and #$07            ; a = a AND #7
0994   b755   sta $55             ; nach $55 retten
0996   97     tax                 ; x = a
0997   a601   lda #$01            ; a = #1
0999   5d     tstx                ; a um x Stellen nach links schieben
099a   2704   beq $09a0           ; (Bitmaske generieren)
099c : 48     lsla                ;
099d   5a     decx                ;
099e   26fc   bne $099c           ;
09a0 : b754   sta $54             ; nach $54 retten
09a2   be56   ldx $56             ; x = $56
09a4   e601   lda $01,x           ; PORTB oder PORTC auslesen
09a6   b454   and $54             ; gewuenschtes Bit ausmaskieren
09a8   b754   sta $54             ;   und nach $54 speichern
09aa   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer BASIC Token 11 b - internes BASIC-Kommando
;      Byteport abfragen
;
;      input : x = Byteport-Nummer (0 oder 1)
;      output: a = Daten vom Port
;      used  : a,$54
;
;      called from $172f
; ---------------------------------------------------------------------------

09ab : bf54   stx $54             ; store index register at address $54
09ad   e601   lda $01,x           ; load accu with value at addr. $01 + x-reg.
09af   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer BASIC Token 12 - internes BASIC-Kommando
;      Wordport abfragen
;
;      input : -
;      output: x = PORTB, a = PORTC
;      used  : a,x
;
;      called from $1736
; ---------------------------------------------------------------------------

09b0 : be01   ldx $01             ; load index reg. with value at addr. $01
09b2   b602   lda $02             ; load accu with value at address $02
09b4   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Unexplored byte
; ---------------------------------------------------------------------------

09b5 : ce     db $ce              ; %11001110

; ---------------------------------------------------------------------------
;      fuer BASIC Token 13 b - internes BASIC-Kommando
;      Bitport auf Ausgang schalten und mit Zustand laden
;
;      input : x = Bitport-Nummer (0..15), $ce = Zustand (HIGH, LOW)
;      output: -
;      used  : a,x,$54-$56
;
;      jumped from $1748
; ---------------------------------------------------------------------------

09b6 : 9f     txa                 ; transfer index register to accumulator
09b7   44     lsra                ; logical shift right accumulator
09b8   44     lsra                ; logical shift right accumulator
09b9   44     lsra                ; logical shift right accumulator
09ba   b755   sta $55             ; store accumulator at address $55
09bc   9f     txa                 ; transfer index register to accumulator
09bd   a407   and #$07            ; AND accu with value #$07
09bf   b756   sta $56             ; store accumulator at address $56
09c1   97     tax                 ; transfer accumulator to index register
09c2   a601   lda #$01            ; load accumulator with value #$01
09c4   5d     tstx                ; test index register for negative or zero
09c5   2704   beq $09cb           ; branch if equal (Z is set)
09c7 : 48     lsla                ; shift left accumulator
09c8   5a     decx                ; decrement index register
09c9   26fc   bne $09c7           ; branch if not equal (Z is clear)
09cb : b754   sta $54             ; store accumulator at address $54
09cd   9b     sei                 ; set interrupt mask (disable interrupts)
09ce   3dce   tst $ce             ; test for negative or zero at address $ce
09d0   2706   beq $09d8           ; branch if equal (Z is set)
09d2   be55   ldx $55             ; load index reg. with value at addr. $55
09d4   ea01   ora $01,x           ; OR accu with value at addr. $01 + x-reg.
09d6   2005   bra $09dd           ; branch always to $09dd

09d8 : 43     coma                ; inverse accumulator (one's complement)
09d9   be55   ldx $55             ; load index reg. with value at addr. $55
09db   e401   and $01,x           ; AND accu with value at address $01 + x
09dd : e701   sta $01,x           ; store accumulator at address $01 + x-reg.
09df   b654   lda $54             ; load accu with value at address $54
09e1   be55   ldx $55             ; load index reg. with value at addr. $55
09e3   ea05   ora $05,x           ; OR accu with value at addr. $05 + x-reg.
09e5   e705   sta $05,x           ; store accumulator at address $05 + x-reg.
09e7   9a     cli                 ; clear interrupt mask (enable interrupts)
09e8   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Unexplored byte
; ---------------------------------------------------------------------------

09e9 : ce     db $ce              ; %11001110

; ---------------------------------------------------------------------------
;      fuer BASIC Token 14 b - internes BASIC-Kommando
;      Byteport auf Ausgang schalten und mit Zustand laden
;
;      input : x = Byteport-Nummer (0 oder 1), $ce = Zustand
;      output: -
;      used  : a,$54
;
;      jumped from $1753
; ---------------------------------------------------------------------------

09ea : bf54   stx $54             ; store index register at address $54
09ec   9b     sei                 ; set interrupt mask (disable interrupts)
09ed   b6ce   lda $ce             ; load accu with value at address $ce
09ef   e701   sta $01,x           ; store accumulator at address $01 + x-reg.
09f1   a6ff   lda #$ff            ; load accumulator with value #$ff
09f3   e705   sta $05,x           ; store accumulator at address $05 + x-reg.
09f5   9a     cli                 ; clear interrupt mask (enable interrupts)
09f6   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Unexplored byte
; ---------------------------------------------------------------------------

09f7 : ce     db $ce              ; %11001110

; ---------------------------------------------------------------------------
;      fuer BASIC Token 15 - internes BASIC-Kommando
;      Wordport auf Ausgang schalten und mit Zustand laden
;
;      input : $ce:$cf = Zustand
;      output: -
;      used  : a,x,$1-$2,$5-$6
;
;      jumped from $175e
; ---------------------------------------------------------------------------

09f8 : 9b     sei                 ; set interrupt mask (disable interrupts)
09f9   b6ce   lda $ce             ; load accu with value at address $ce
09fb   b701   sta $01             ; store accumulator at address $01
09fd   b6cf   lda $cf             ; load accu with value at address $cf
09ff   b702   sta $02             ; store accumulator at address $02
0a01   aeff   ldx #$ff            ; load index register with value #$ff
0a03   9f     txa                 ; transfer index register to accumulator
0a04   b706   sta $06             ; store accumulator at address $06
0a06   bf05   stx $05             ; store index register at address $05
0a08   9a     cli                 ; clear interrupt mask (enable interrupts)
0a09   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer BASIC Token 80 b - TOG
;      Bitport invertieren
;
;      input : x = Bitport-Nummer (0..15)
;      output: -
;      used  : a,x,$54-$56
;
;      jumped from $177e
; ---------------------------------------------------------------------------

0a0a : 9f     txa                 ; transfer index register to accumulator
0a0b   44     lsra                ; logical shift right accumulator
0a0c   44     lsra                ; logical shift right accumulator
0a0d   44     lsra                ; logical shift right accumulator
0a0e   b756   sta $56             ; store accumulator at address $56
0a10   9f     txa                 ; transfer index register to accumulator
0a11   a407   and #$07            ; AND accu with value #$07
0a13   b755   sta $55             ; store accumulator at address $55
0a15   97     tax                 ; transfer accumulator to index register
0a16   a601   lda #$01            ; load accumulator with value #$01
0a18   5d     tstx                ; test index register for negative or zero
0a19   2704   beq $0a1f           ; branch if equal (Z is set)
0a1b : 48     lsla                ; shift left accumulator
0a1c   5a     decx                ; decrement index register
0a1d   26fc   bne $0a1b           ; branch if not equal (Z is clear)
0a1f : b754   sta $54             ; store accumulator at address $54
0a21   be56   ldx $56             ; load index reg. with value at addr. $56
0a23   e801   eor $01,x           ; XOR accu with value at addr. $01 + x
0a25   e701   sta $01,x           ; store accumulator at address $01 + x-reg.
0a27   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer BASIC Token 81 b - PULSE
;      einen Impuls auf einem Bitport ausgeben
;
;      input : x = Bitport-Nummer (0 bis 15)
;      output: -
;      used  : a,x,$54,$55,$57
;
;      jumped from $1785
; ---------------------------------------------------------------------------

0a28 : 9f     txa                 ; transfer index register to accumulator
0a29   44     lsra                ; logical shift right accumulator
0a2a   44     lsra                ; logical shift right accumulator
0a2b   44     lsra                ; logical shift right accumulator
0a2c   b757   sta $57             ; store accumulator at address $57
0a2e   9f     txa                 ; transfer index register to accumulator
0a2f   a407   and #$07            ; AND accu with value #$07
0a31   b755   sta $55             ; store accumulator at address $55
0a33   97     tax                 ; transfer accumulator to index register
0a34   a601   lda #$01            ; load accumulator with value #$01
0a36   5d     tstx                ; test index register for negative or zero
0a37   2704   beq $0a3d           ; branch if equal (Z is set)
0a39 : 48     lsla                ; shift left accumulator
0a3a   5a     decx                ; decrement index register
0a3b   26fc   bne $0a39           ; branch if not equal (Z is clear)
0a3d : b754   sta $54             ; store accumulator at address $54
0a3f   be57   ldx $57             ; load index reg. with value at addr. $57
0a41   ea05   ora $05,x           ; OR accu with value at addr. $05 + x-reg.
0a43   e705   sta $05,x           ; store accumulator at address $05 + x-reg.
0a45   b654   lda $54             ; load accu with value at address $54
0a47   e801   eor $01,x           ; XOR accu with value at addr. $01 + x
0a49   e701   sta $01,x           ; store accumulator at address $01 + x-reg.
0a4b   9d     nop                 ; no operation (wait for two cycles)
0a4c   9d     nop                 ; no operation (wait for two cycles)
0a4d   9d     nop                 ; no operation (wait for two cycles)
0a4e   9d     nop                 ; no operation (wait for two cycles)
0a4f   9d     nop                 ; no operation (wait for two cycles)
0a50   9d     nop                 ; no operation (wait for two cycles)
0a51   9d     nop                 ; no operation (wait for two cycles)
0a52   9d     nop                 ; no operation (wait for two cycles)
0a53   9d     nop                 ; no operation (wait for two cycles)
0a54   9d     nop                 ; no operation (wait for two cycles)
0a55   b654   lda $54             ; load accu with value at address $54
0a57   e801   eor $01,x           ; XOR accu with value at addr. $01 + x
0a59   e701   sta $01,x           ; store accumulator at address $01 + x-reg.
0a5b   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer BASIC Token 82 b - DEACT
;      Bitport deaktivieren
;
;      input : x = Bitport-Nummer (0 bis 15)
;      output: -
;      used  : a,x,$54-$57
;
;      jumped from $178c
; ---------------------------------------------------------------------------

0a5c : bf56   stx $56             ; store index register at address $56
0a5e   9f     txa                 ; transfer index register to accumulator
0a5f   44     lsra                ; logical shift right accumulator
0a60   44     lsra                ; logical shift right accumulator
0a61   44     lsra                ; logical shift right accumulator
0a62   b757   sta $57             ; store accumulator at address $57
0a64   9f     txa                 ; transfer index register to accumulator
0a65   a407   and #$07            ; AND accu with value #$07
0a67   b755   sta $55             ; store accumulator at address $55
0a69   97     tax                 ; transfer accumulator to index register
0a6a   a601   lda #$01            ; load accumulator with value #$01
0a6c   5d     tstx                ; test index register for negative or zero
0a6d   2704   beq $0a73           ; branch if equal (Z is set)
0a6f : 48     lsla                ; shift left accumulator
0a70   5a     decx                ; decrement index register
0a71   26fc   bne $0a6f           ; branch if not equal (Z is clear)
0a73 : b754   sta $54             ; store accumulator at address $54
0a75   43     coma                ; inverse accumulator (one's complement)
0a76   be57   ldx $57             ; load index reg. with value at addr. $57
0a78   e405   and $05,x           ; AND accu with value at address $05 + x
0a7a   e705   sta $05,x           ; store accumulator at address $05 + x-reg.
0a7c   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer BASIC Token 83 b - DEACT
;      Byteport deaktivieren
;
;      input : x = Byteport-Nummer (0 oder 1)
;      output: -
;      used  : $56
;
;      jumped from $1793
; ---------------------------------------------------------------------------

0a7d : bf56   stx $56             ; store index register at address $56
0a7f   6f05   clr $05,x           ; clear memory at $05 + index register
0a81   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      BASIC Token 84 - DEACT
;      Wordport deaktivieren
;
;      input : -
;      output: -
;      used  : $5-$6
;
;      called from $1e9e
; ---------------------------------------------------------------------------

0a82 : 3f05   clr $05             ; clear memory at address $05
0a84   3f06   clr $06             ; clear memory at address $06
0a86   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer BASIC Token 16 b - internes BASIC-Kommando
;      Daten vom AD-Port lesen
;
;      input : x = Nummer des AD-Ports (0..7)
;      output: a = Wert, x = 0
;      used  : a,x,$9
;
;      called from $1765
; ---------------------------------------------------------------------------

0a87 : b609   lda $09             ; load accu with value at address $09
0a89   a4f0   and #$f0            ; AND accu with value #$f0
0a8b   b709   sta $09             ; store accumulator at address $09
0a8d   9f     txa                 ; transfer index register to accumulator
0a8e   a40f   and #$0f            ; AND accu with value #$0f
0a90   ba09   ora $09             ; OR accu with value at address $09
0a92   b709   sta $09             ; store accumulator at address $09
0a94 : 0f09fd brclr #7,$09,$0a94  ; branch to $0a94 if bit #7 at $09 is clear
0a97   b608   lda $08             ; load accu with value at address $08
0a99   5f     clrx                ; clear index register
0a9a   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Unexplored bytes
; ---------------------------------------------------------------------------

0a9b :        db $81,$ce

; ---------------------------------------------------------------------------
;      fuer BASIC Token 17 b - internes BASIC-Kommando
;      Daten zu einem DA-Port senden
;
;      input : x = Nummer des DA-Ports (0 oder 1), $ce = Wert
;      output: -
;      used  : a,$54
;
;      jumped from $1777
; ---------------------------------------------------------------------------

0a9d : bf54   stx $54             ; store index register at address $54
0a9f   b6ce   lda $ce             ; load accu with value at address $ce
0aa1   e70a   sta $0a,x           ; store accumulator at address $0a + x-reg.
0aa3   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Befehlsbyte von der RS232 Schnittstelle empfangen & interpretieren
;
;      input : -
;      output: -
;      used  : a,x,$0(%01000111),$4(%00000001),$7(%00000111),$11,$54-$59,
;              $63-$64,$66-$67,$6a-$6b,$7b(%00010000),$80-$82,$89,$90,
;              $c8-$d4,$d9-$da,$dd-$df,$e1
;
;      called from $0986
; ---------------------------------------------------------------------------

0aa4 : cd0cb5 jsr $0cb5           ; lese ein Byte von der RS232
0aa7   b754   sta $54             ; speichere es auf $54 zwischen
0aa9   97     tax                 ; x=a
0aaa   5a     decx                ; war das Byte = #1 ?
0aab   2717   beq $0ac4           ; wenn ja, Einschaltmeldung ausgeben
0aad   5a     decx                ; war das Byte = #2 ?
0aae   2716   beq $0ac6           ; wenn ja, BASIC-Programm empfangen
0ab0   5a     decx                ; war das Byte = #3 ?
0ab1   2715   beq $0ac8           ; wenn ja, ASCII-Dump des BASIC-Prgs.
0ab3   a305   cmpx #$05           ; war das Byte = #8 ?
0ab5   2713   beq $0aca           ; wenn ja, internes EEPROM programmieren
0ab7   a306   cmpx #$06           ; war das Byte = #9 ?
0ab9   2718   beq $0ad3           ; wenn ja, ASCII-Dump des int. EEPROMs
0abb   a30a   cmpx #$0a           ; war das Byte = #13 ?
0abd   2711   beq $0ad0           ; wenn ja, Word-Dump der Datendatei
0abf   a30b   cmpx #$0b           ; war das Byte = #14 ?
0ac1   270a   beq $0acd           ; wenn ja, Uhr stellen
0ac3   81     rts                 ; return from subroutine

0ac4 : 2010   bra $0ad6           ; springe in die verschiedenen Subroutinen
0ac6 : 2026   bra $0aee           ;
0ac8 : 2078   bra $0b42           ;
0aca : cc0b9f jmp $0b9f           ;
0acd : cc0bff jmp $0bff           ;
0ad0 : cc1b2d jmp $1b2d           ;
0ad3 : cc0bca jmp $0bca           ;

; ---------------------------------------------------------------------------
;      RS232-Befehl ASCII-Code 1 - Einschaltmeldung ausgeben
;
;      input : -
;      output: -
;      used  : a,x,$11,$ce
;
;      jumped from $0ac4
; ---------------------------------------------------------------------------

0ad6 : 3fce   clr $ce             ; RS232-Befehl ASCII-Code 1 empfangen:
0ad8   2008   bra $0ae2           ; Einschaltmeldung ausgeben
0ada : de1d76 ldx $1d76,x         ;
0add   cd0c77 jsr $0c77           ;
0ae0   3cce   inc $ce             ;
0ae2 : bece   ldx $ce             ;
0ae4   d61d76 lda $1d76,x         ;
0ae7   26f1   bne $0ada           ;
0ae9   ae0d   ldx #$0d            ;
0aeb   cc0c77 jmp $0c77           ; beenden

; ---------------------------------------------------------------------------
;      RS232-Befehl ASCII-Code 2 - Programmieren des seriellen EEPROMS
;      die naechsten zwei uebertragenen Bytes geben die Anzahl der zu
;      programmierenden Bytes an, dann folgen die Programmbytes
;
;      Die Anzahl der zu uebertragenen Bytes (die Laenge des BASIC-
;      Programms) wird ins EEPROM an Adresse 0 & 1 kopiert. Die Bytes
;      an den EEPROM-Adressen 2 & 3 (Groesse der Datendatei im EEPROM)
;      werden auf 0 gesetzt. Anschliessend wird das BASIC-Programm ab
;      Adresse 4 gespeichert.
;
;      input : -
;      output: -
;      used  : a,x,$0(%01000111),$4(%00000001),$11,$54,$63-$64,$66-$67,
;              $ce-$d1,$d3-$d4,$e1
;
;      jumped from $0ac6
; ---------------------------------------------------------------------------

0aee : 1500   bclr #2,$00         ; RUN-LED einschalten
0af0   5f     clrx                ;
0af1   4f     clra                ;
0af2   b7d4   sta $d4             ; $d3:$d4 = #0
0af4   bfd3   stx $d3             ;
0af6   cd0d89 jsr $0d89           ; $66:$67 = #0 setzen
0af9   cd0cb5 jsr $0cb5           ; ein Byte von der RS232 holen
0afc   b7cf   sta $cf             ; auf $cf speichern
0afe   97     tax                 ;
0aff   cd0d92 jsr $0d92           ; ins EEPROM speichern
0b02   becf   ldx $cf             ; x = $cf
0b04   cd0c77 jsr $0c77           ; empfangenes Byte quittieren
0b07   cd0cb5 jsr $0cb5           ; ein Byte von der RS232 holen
0b0a   b7d0   sta $d0             ; auf $d0 speichern
0b0c   97     tax                 ;
0b0d   cd0d92 jsr $0d92           ; ins EEPROM speichern
0b10   bed0   ldx $d0             ; x = $d0
0b12   cd0c77 jsr $0c77           ; empfangenes Byte quittieren
0b15   5f     clrx                ; x = #0
0b16   cd0d92 jsr $0d92           ; ins EEPROM speichern
0b19   5f     clrx                ; x = #0
0b1a   cd0d92 jsr $0d92           ; ins EEPROM speichern
0b1d   201a   bra $0b39           ; zum Schleifenstart springen

0b1f : cd0cb5 jsr $0cb5           ; ein Byte von der RS232 holen
0b22   b7ce   sta $ce             ; auf $ce speichern
0b24   97     tax                 ;
0b25   cd0d92 jsr $0d92           ; ins EEPROM speichern
0b28   bece   ldx $ce             ; x = $ce
0b2a   cd0c77 jsr $0c77           ; empfangenes Byte quittieren
0b2d   b6d0   lda $d0             ;
0b2f   a001   sub #$01            ; Schleifenzaehler $cf:$d0 dekrementieren
0b31   b7d0   sta $d0             ;
0b33   b6cf   lda $cf             ;
0b35   a200   sbc #$00            ;
0b37   b7cf   sta $cf             ;
0b39 : b6cf   lda $cf             ;
0b3b   bad0   ora $d0             ; solange weitermachen bis der
0b3d   26e0   bne $0b1f           ; Schleifenzaehler = #0 ist

0b3f   1400   bset #2,$00         ; RUN-LED ausschalten
0b41   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      RS232-Befehl ASCII-Code 3 - ASCII-Dump des BASIC-Programms
;      zuerst wird die Groesse des Programms in Bytes ASCII-kodiert
;      und gefolgt von einem Return ausgegeben, dann folgt das BASIC-
;      Programm
;
;      input : -
;      output: -
;      used  : a,x,$0(%00000011),$4(%00000001),$11,$54-$59,$66-$67,$ce-$d1,
;              $d3-$d4,$d9-$da,$dd-$df,$e1
;
;      jumped from $0ac8
; ---------------------------------------------------------------------------

0b42 : 5f     clrx                ; Counter fuer sequentielle EEPROM-
0b43   4f     clra                ; Zugriffe im Mikrokontroller und im
0b44   b7d4   sta $d4             ; EEPROM auf null setzen
0b46   bfd3   stx $d3             ;
0b48   cd0de5 jsr $0de5           ; erstes Word aus dem EEPROM (Laenge des
0b4b   cd0e0d jsr $0e0d           ; BASIC-Programms) holen und auf $ce:$cf
0b4e   b7cf   sta $cf             ; speichern
0b50   bfce   stx $ce             ;
0b52   cd0e01 jsr $0e01           ; sequentielles Lesen vom EEPROM beenden
0b55   b6ce   lda $ce             ;
0b57   a1ff   cmp #$ff            ; war das gelesene Word <> #$ffff ?
0b59   260c   bne $0b67           ; dann nach $b67 springen
0b5b   b6cf   lda $cf             ;
0b5d   a1ff   cmp #$ff            ;
0b5f   2606   bne $0b67           ; falls nein, dann Laenge gleich #1
0b61   3fce   clr $ce             ; setzen (dieser Fall tritt dann ein,
0b63   a601   lda #$01            ; wenn EEPROM noch nie benutzt wurde)
0b65   b7cf   sta $cf             ;
0b67 : b6ce   lda $ce             ; Laenge des BASIC-Programms als ASCII-
0b69   b7d0   sta $d0             ; String auf RS232 ausgeben
0b6b   b6cf   lda $cf             ;
0b6d   b7d1   sta $d1             ;
0b6f   cd0ce8 jsr $0ce8           ;
0b72   ae0d   ldx #$0d            ; gefolgt von einem Return
0b74   cd0c77 jsr $0c77           ;
0b77   5f     clrx                ; Counter fuer sequentielle EEPROM-
0b78   a604   lda #$04            ; Zugriffe im Mikrokontroller und im
0b7a   b7d4   sta $d4             ; EEPROM auf #$0004 (Anfang des BASIC-
0b7c   bfd3   stx $d3             ; programms) setzen
0b7e   cd0de5 jsr $0de5           ;
0b81   2013   bra $0b96           ; springe zum Schleifenstart

0b83 : cd0e04 jsr $0e04           ; ein Byte vom EEPROM holen
0b86   97     tax                 ;
0b87   cd0c77 jsr $0c77           ; und auf RS232 ausgeben
0b8a   b6cf   lda $cf             ;
0b8c   a001   sub #$01            ;
0b8e   b7cf   sta $cf             ; Zaehler dekrementieren
0b90   b6ce   lda $ce             ;
0b92   a200   sbc #$00            ;
0b94   b7ce   sta $ce             ;
0b96 : b6ce   lda $ce             ; ist Zaehler = #0 ?
0b98   bacf   ora $cf             ; falls nein, weiter mit Schleife
0b9a   26e7   bne $0b83           ;
0b9c   cc0e01 jmp $0e01           ; sequentielles Lesen vom EEPROM beenden

; ---------------------------------------------------------------------------
;      RS232-Befehl ASCII-Code 8 - Programmieren des internen EEPROMS
;      das naechste gesendete Byte gibt Anzahl der zu programmierenden
;      Bytes an, dann folgen die eigentlichen Daten
;
;      input : -
;      output: -
;      used  : a,x,$0(%01000100),$7(%00000111),$11,$54-$55,$63-$64,$ce-$d2
;
;      jumped from $0aca
; ---------------------------------------------------------------------------

0b9f : 1500   bclr #2,$00         ; RUN-LED einschalten
0ba1   cd0cb5 jsr $0cb5           ; ein Byte von der RS232 holen und
0ba4   b7cf   sta $cf             ;   nach $cf speichern
0ba6   97     tax                 ;
0ba7   cd0c77 jsr $0c77           ; das empfangene Byte als Quittung senden
0baa   5f     clrx                ; Index Register loeschen
0bab   2014   bra $0bc1           ; zum Schleifenstart springen

0bad : cd0cb5 jsr $0cb5           ; ein Byte von der RS232 holen und
0bb0   b7ce   sta $ce             ;   nach $ce und nach $d1 speichern
0bb2   b7d1   sta $d1             ;
0bb4   bed0   ldx $d0             ; x mit Schleifenzaehler laden
0bb6   cd0c26 jsr $0c26           ; und Byte ins EEPROM programmieren
0bb9   bece   ldx $ce             ;
0bbb   cd0c77 jsr $0c77           ; das programmierte Byte quittieren
0bbe   bed0   ldx $d0             ; x mit Schleifenzaehler laden
0bc0   5c     incx                ; x inkrementieren
0bc1 : bfd0   stx $d0             ; Schleifenzaehler mit x laden
0bc3   b3cf   cmpx $cf            ; x mit $cf vergleichen
0bc5   25e6   blo $0bad           ; falls x < $cf, mit Schleife weitermachen

0bc7   1400   bset #2,$00         ; RUN-LED ausschalten
0bc9   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      RS232-Befehl ASCII-Code 9 - ASCII-Dump des internen EEPROMS
;      wirklich schrecklich programmiert! eben typisch C
;
;      input : -
;      output: -
;      used  : a,x,$11,$54-$57,$ce-$cf,$dd-$df
;
;      jumped from $0ad3
; ---------------------------------------------------------------------------

0bca : 3fce   clr $ce             ; $ce:$cf = #0
0bcc   3fcf   clr $cf             ;
0bce   201b   bra $0beb           ; zum Schleifenstart springen

0bd0 : b6cf   lda $cf             ; $de:$df = $ce:$cf + #$0101
0bd2   ab01   add #$01            ;
0bd4   b7df   sta $df             ;
0bd6   b6ce   lda $ce             ;
0bd8   a901   adc #$01            ;
0bda   b7de   sta $de             ;
0bdc   97     tax                 ;
0bdd   b6df   lda $df             ; Wert von Adresse $de:$df ins x-Register
0bdf   cd1cfc jsr $1cfc           ;
0be2   cd0c77 jsr $0c77           ; und ueber RS232 senden
0be5   3ccf   inc $cf             ;
0be7   2602   bne $0beb           ; $ce:$cf inkrementieren
0be9   3cce   inc $ce             ;
0beb : 3f56   clr $56             ; $56:$57 = #$ff
0bed   a6ff   lda #$ff            ;
0bef   b757   sta $57             ;
0bf1   b6ce   lda $ce             ; $54:$55 = $ce:$cf
0bf3   b754   sta $54             ;
0bf5   b6cf   lda $cf             ;
0bf7   b755   sta $55             ;
0bf9   cd1b6b jsr $1b6b           ; vergleiche $54:$55 mit $56:$57
0bfc   2bd2   bmi $0bd0           ; springe, falls $54:$55 kleiner ist

0bfe   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      RS232-Befehl ASCII-Code 14 - Uhr stellen
;      Die Zeit wird Byte-fuer-Byte uebertragen:
;      1. Byte: Sekunde
;      2. Byte: Minute
;      3. Byte: Stunde
;      4. Byte: Wochentag
;      5. Byte: Tag
;      6. Byte: Monat
;      7. Byte: Jahr
;
;      input : -
;      output: -
;      used  : a,x,$0(%01000000),$54,$63-$64,$6a-$6b,$7b(%00010000),
;              $80-$82,$89,$90
;
;      jumped from $0acd
; ---------------------------------------------------------------------------

0bff : cd0cb5 jsr $0cb5           ; Sekunde empfangen
0c02   b789   sta $89             ;
0c04   cd0cb5 jsr $0cb5           ; Minute empfangen
0c07   b781   sta $81             ;
0c09   cd0cb5 jsr $0cb5           ; Stunde empfangen
0c0c   b780   sta $80             ;
0c0e   cd0cb5 jsr $0cb5           ; Wochentag empfangen
0c11   b76b   sta $6b             ;
0c13   cd0cb5 jsr $0cb5           ; Tag empfangen
0c16   b76a   sta $6a             ;
0c18   cd0cb5 jsr $0cb5           ; Monat empfangen
0c1b   b782   sta $82             ;
0c1d   cd0cb5 jsr $0cb5           ; Jahr empfangen
0c20   b790   sta $90             ;
0c22   187b   bset #4,$7b         ; TIME-SET-Bit setzen
0c24   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Unexplored byte
; ---------------------------------------------------------------------------

0c25 : d1     db $d1              ; %11010001

; ---------------------------------------------------------------------------
;      ein Byte ins interne EEPROM programmieren
;
;      input : x=Adresse ($0100+x), $d1=Bytewert
;      output: -
;      used  : a,x,$7(%00000111),$54-$55,$d2
;
;      called from $0bb6
; ---------------------------------------------------------------------------

0c26 : bfd2   stx $d2             ; x an Adresse $d2 zwischenspeichern
0c28   9b     sei                 ; set interrupt mask (disable interrupts)
0c29   1207   bset #1,$07         ; E1LAT setzen
0c2b   1407   bset #2,$07         ; E1ERA setzen
0c2d   a6ff   lda #$ff            ;
0c2f   d70101 sta $0101,x         ; zuerst #$ff ins EEPROM schreiben
0c32   1007   bset #0,$07         ; E1PGM setzen
0c34   ad13   bsr $0c49           ; 69 ms warten
0c36   1307   bclr #1,$07         ; E1LAT loeschen
0c38   1207   bset #1,$07         ; E1LAT setzen
0c3a   b6d1   lda $d1             ;
0c3c   bed2   ldx $d2             ; dann gewuenschtes Byte schreiben
0c3e   d70101 sta $0101,x         ;
0c41   1007   bset #0,$07         ; E1PGM setzen
0c43   ad04   bsr $0c49           ; 69 ms warten
0c45   1307   bclr #1,$07         ; E1LAT loeschen
0c47   9a     cli                 ; clear interrupt mask (enable interrupts)
0c48   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Verzoegerung zum Programmieren des internen EEPROMS
;      (etwa 69 ms, lt. Motorola sind nur 10 ms noetig!)
;
;      15+21+6000*(21+2)+6 = 138042 Takte
;      (bei 2 MHz internem Takt entspricht das 69 ms)
;
;      input : -
;      output: -
;      used  : a,x,$54,$55
;
;      called from $0c34,$0c43
; ---------------------------------------------------------------------------

0c49 : ae17   ldx #$17            ; 2 Takte  \
0c4b   a670   lda #$70            ; 2 Takte   \
0c4d   b755   sta $55             ; 4 Takte    > 15 Takte
0c4f   bf54   stx $54             ; 4 Takte   /
0c51   2001   bra $0c54           ; 3 Takte  /

0c53 : 9d     nop                 ; 2 Takte --->  2 Takte
0c54 : b655   lda $55             ; 3 Takte \
0c56   a001   sub #$01            ; 2 Takte  \
0c58   b755   sta $55             ; 4 Takte   \
0c5a   b654   lda $54             ; 3 Takte    > 21 Takte
0c5c   a200   sbc #$00            ; 2 Takte   /
0c5e   b754   sta $54             ; 4 Takte  /
0c60   24f1   bhs $0c53           ; 3 Takte /
0c62   81     rts                 ; 6 Takte --->  6 Takte

; ---------------------------------------------------------------------------
;      nach Reset RS232 Schnittstelle auf 9600 Baud initialisieren
;
;      input : -
;      output: -
;      used  : a,x,$0(%01000000),$4(%01000000),$d-$f,$63-$65
;
;      called from $0954
; ---------------------------------------------------------------------------

0c63 : ad7b   bsr $0ce0           ; Ringbufferzeiger und Anzahl initialisieren
0c65   aec0   ldx #$c0            ; x-reg. = R9600 (Konstante fuer 9600 Baud)
0c67   ad0b   bsr $0c74           ; in Baudratengenerator laden
0c69   3f0e   clr $0e             ; alle Bits im SCI control reg. 1 loeschen
0c6b   a62c   lda #$2c            ; Wert #$2c in das
0c6d   b70f   sta $0f             ;   SCI control register 2 speichern
0c6f   1c04   bset #6,$04         ; RTS-Pin auf Ausgang schalten
0c71   1d00   bclr #6,$00         ; RTS-Pin auf 0 Volt setzen
0c73   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Baudratengenerator laden
;
;      input : x=Baudratenkonstante
;      output: -
;      used  : $d
;
;      called from $0c67,$19e3
; ---------------------------------------------------------------------------

0c74 : bf0d   stx $0d             ; store index register at address $0d
0c76   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Ein Zeichen ueber die serielle Schnittstelle (RS232) ausgeben
;
;      input : x=Zeichen
;      output: -
;      used  : $11
;
;      called from $0add,$0aeb,$0b04,$0b12,$0b2a,$0b74,$0b87,$0ba7,$0bbb,
;                  $0be2,$0c77,$0cf2,$0cfa,$0d4f,$0d5e,$18e2,$18ef,$1b3d,
;                  $1b59
; ---------------------------------------------------------------------------

0c77 : 0d10fd brclr #6,$10,$0c77  ; auf Transmit complete flag warten
0c7a   bf11   stx $11             ; x ins SCI data register schreiben
0c7c   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      wird bei jedem Serial communications interface-Interrupt aufgerufen
;      und fuegt ein von der seriellen Schnittstelle empfangenes Zeichen
;      in den internen, acht Byte grossen RS232-Buffer ein
;
;      used  : a,x,$0(%01000000),$63,$65,$d7-$d8
;
;      called from $1ff2 (SCI)
; ---------------------------------------------------------------------------

0c7d : 0a1027 brset #5,$10,$0ca7  ; Receive data register full flag testen
0c80 : 4f     clra                ; Akku bei Fehler loeschen
0c81 : b7d8   sta $d8             ; Fehlermarker auf Adresse $d8 speichern
0c83   b611   lda $11             ; load accu with SCI data register
0c85   b7d7   sta $d7             ; gelesenes Byte auf Adresse $d7 speichern
0c87   3dd8   tst $d8             ; wurde ein Fehler detektiert?
0c89   271b   beq $0ca6           ; falls ja, beenden
0c8b   b663   lda $63             ; Ist die Anzahl der noch zu lesenden Bytes
0c8d   a108   cmp #$08            ; im Ringbuffer groesser oder gleich #8?
0c8f   2415   bhs $0ca6           ; falls ja, ist Buffer voll, beenden
0c91   b6d7   lda $d7             ;
0c93   be65   ldx $65             ; das von der RS232 gelesenes Byte in
0c95   e75b   sta $5b,x           ;   den Ringbuffer einfuegen
0c97   3c65   inc $65             ; den Pointer auf den naechsten freien
0c99   a607   lda #$07            ;   Platz im Buffer inkrementieren
0c9b   b465   and $65             ;   (falls >7 auf 0 setzen)
0c9d   b765   sta $65             ;
0c9f   3c63   inc $63             ; Anzahl der zu lesenden Bytes inkrement.
0ca1   0f7b02 brclr #7,$7b,$0ca6  ; RTS & CTS Handshake aktiviert?
0ca4   1c00   bset #6,$00         ; dann RTS auf 5 Volt setzen
0ca6 : 80     rti                 ; return from interrupt

0ca7 : 051002 brclr #2,$10,$0cac  ; springe wenn Noise error flag is clear
0caa   20d4   bra $0c80           ; branch always to $0c80

0cac : 031002 brclr #1,$10,$0cb1  ; springe wenn Framing error flag is clear
0caf   20cf   bra $0c80           ; branch always to $0c80

0cb1 : a601   lda #$01            ; Akku = #1, falls kein Fehler auftrat
0cb3   20cc   bra $0c81           ; branch always to $0c81

; ---------------------------------------------------------------------------
;      solange warten, bis ein Byte von der serielle Schnittstelle
;      empfangen und in den Ringpuffer eingefuegt wurde, dann ein Byte
;      aus dem Buffer holen
;
;      input : -
;      output: a=$54=das gelesene Byte
;      used  : a,x,$0(%01000000),$54,$63-$64
;
;      called from $0aa4,$0af9,$0b07,$0b1f,$0ba1,$0bad,$0bff,$0c04,$0c09,
;                  $0c0e,$0c13,$0c18,$0c1d,$18f9,$191b
; ---------------------------------------------------------------------------

0cb5 : 1d00   bclr #6,$00         ; RTS auf 0 Volt setzen
0cb7 : ad15   bsr $0cce           ; warte solange, bis die serielle
0cb9   4d     tsta                ; Schnittstelle ein Byte empfangen hat
0cba   27fb   beq $0cb7           ;
0cbc   be64   ldx $64             ; ein Byte aus dem Buffer der seriellen
0cbe   ee5b   ldx $5b,x           ; Schnittstelle holen
0cc0   bf54   stx $54             ; und auf Adresse $54 speichern
0cc2   3c64   inc $64             ;
0cc4   a607   lda #$07            ; Pointer auf das naechste Byte inkrement.
0cc6   b464   and $64             ;   und falls >7 ist, auf 0 setzen
0cc8   b764   sta $64             ;
0cca   3a63   dec $63             ; Anzahl der Bytes im Buffer dekrementieren
0ccc   9f     txa                 ; Akku = das gelesene Byte
0ccd   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Ueberpruefen, ob ein Byte von der seriellen Schnittstelle geholt
;      werden kann
;
;      input : $63
;      output: a=1 wenn Daten da, a=0 wenn keine Daten vorhanden
;      used  : a,$0(%01000000)
;
;      called from $0980,$0cb7,$18f2
; ---------------------------------------------------------------------------

0cce : 1d00   bclr #6,$00         ; RTS auf 0 Volt setzen
0cd0   3d63   tst $63             ; ist ein zu lesendes Bytes im Buffer?
0cd2   2703   beq $0cd7           ; falls ja,
0cd4   a601   lda #$01            ;   lade Akku mit 1
0cd6   81     rts                 ; return from subroutine

0cd7 : 4f     clra                ; Akku = #0, falls keine Daten da
0cd8   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer BASIC Token 37 - CTS
;      Abfrage, ob die CTS-Leitung aktiv ist (Leitung ist low-aktiv)
;
;      input : -
;      output: a=1 wenn CTS-Bit nicht gesetzt ist, a=0 wenn doch
;      used  : a
;
;      called from $190e
; ---------------------------------------------------------------------------

0cd9 : 4f     clra                ; clear accumulator
0cda   0e0001 brset #7,$00,$0cde  ; branch to $0cde if bit #7 at $00 is set
0cdd   4c     inca                ; increment accumulator
0cde : 81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Unexplored byte
; ---------------------------------------------------------------------------

0cdf : 81     db $81              ; %10000001

; ---------------------------------------------------------------------------
;      nach Reset die beiden Ringbufferzeiger der RS232 initialisieren
;      und die Anzahl der Bytes im Buffer auf null setzen
;
;      input : -
;      output: -
;      used  : $63-$65
;
;      called from $0c63
; ---------------------------------------------------------------------------

0ce0 : 3f65   clr $65             ; clear memory at address $65
0ce2   3f64   clr $64             ; clear memory at address $64
0ce4   3f63   clr $63             ; clear memory at address $63
0ce6   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Unexplored byte
; ---------------------------------------------------------------------------

0ce7 : d0     db $d0              ; %11010000

; ---------------------------------------------------------------------------
;      Zahl als ASCII-String dezimal kodiert auf RS232 ausgeben
;      die Zahl -32768 wird nicht richtig ausgegeben, was an einem
;      Bug in der Divisionsroutine des Betriebssystems liegt
;
;      wert=2035                  ' entsprechende Logik in BASIC
;      merker=0                   '  programmiert
;      for i=0 to 4
;        w=peekw($1dd7+2*i)       ' Word aus Tabelle holen
;        if wert>=w then
;          print chr$(48+wert\w);
;          merker=1
;        elseif merker=1 then
;          print "0";
;        end if
;        wert=wert MOD w
;      next i
;
;      input : $d0:$d1 = Zahl (Word)
;      output: -
;      used  : a,x,$11,$54-$59,$d0-$d1,$d9-$da,$dd-$df
;
;      called from $0b6f,$18dc,$1b38,$1b54
; ---------------------------------------------------------------------------

0ce8 : 3fda   clr $da             ; Merker zur Unterdrueckung von fuehrenden
0cea   b6d0   lda $d0             ; Nullen loeschen
0cec   bad1   ora $d1             ;
0cee   2604   bne $0cf4           ; falls die zu uebertragende Zahl null
0cf0   ae30   ldx #$30            ;   ist, einfach
0cf2   2083   bra $0c77           ;   "0" ueber RS232 senden

0cf4 : 3dd0   tst $d0             ; ist die Zahl negativ?
0cf6   2a12   bpl $0d0a           ; falls nein, springe
0cf8   ae2d   ldx #$2d            ;
0cfa   cd0c77 jsr $0c77           ; falls doch, "-" ausgeben
0cfd   bed0   ldx $d0             ; und die Zahl invertieren
0cff   b6d1   lda $d1             ;
0d01   53     comx                ;
0d02   40     nega                ;
0d03   2501   blo $0d06           ;
0d05   5c     incx                ;
0d06 : b7d1   sta $d1             ;
0d08   bfd0   stx $d0             ;
0d0a : 3fd9   clr $d9             ; Zaehler von 0 bis 4
0d0c   2073   bra $0d81           ; zum Schleifenstart springen

0d0e : 5f     clrx                ; $de:$df = #$1dd7 + #2*Zaehler
0d0f   48     lsla                ; (Adresse in der Tabelle berechnen)
0d10   59     rolx                ; (in der Adresse stehen die Worte:
0d11   abd7   add #$d7            ;  10000,1000,100,10,1, alles dezimal)
0d13   b7df   sta $df             ;
0d15   9f     txa                 ;
0d16   a91d   adc #$1d            ;
0d18   b7de   sta $de             ;
0d1a   ae56   ldx #$56            ; $56:$57 = Word von Adresse $de:$df
0d1c   cd1cc9 jsr $1cc9           ; (Word aus Tabelle holen)
0d1f   b6d0   lda $d0             ;
0d21   b754   sta $54             ; vergleiche $54:$55 mit $56:57
0d23   b6d1   lda $d1             ;
0d25   b755   sta $55             ; ist das Tabellenword groesser
0d27   cd1b6b jsr $1b6b           ;   als die Zahl?
0d2a   2b2c   bmi $0d58           ; falls ja, springe

0d2c   b6d9   lda $d9             ; Akku mit Zaehler laden
0d2e   5f     clrx                ; $de:$df = #$1dd7 + #2*Zaehler
0d2f   48     lsla                ; (Adresse in der Tabelle berechnen)
0d30   59     rolx                ; (genau wie oben)
0d31   abd7   add #$d7            ;
0d33   b7df   sta $df             ;
0d35   9f     txa                 ;
0d36   a91d   adc #$1d            ;
0d38   b7de   sta $de             ; $56:$57 = Word von Adresse $de:$df
0d3a   ae56   ldx #$56            ; (Word aus Tabelle holen)
0d3c   cd1cc9 jsr $1cc9           ; (genau wie oben)
0d3f   b6d0   lda $d0             ;
0d41   b754   sta $54             ;
0d43   b6d1   lda $d1             ;
0d45   b755   sta $55             ;
0d47   cd1c37 jsr $1c37           ; $54:55 durch $56:$57 dividieren
0d4a   b655   lda $55             ;
0d4c   ab30   add #$30            ; zum Ergebnis "0" (#$30) addieren
0d4e   97     tax                 ;
0d4f   cd0c77 jsr $0c77           ; und ueber die RS232 ausgeben
0d52   a601   lda #$01            ; Merker zum Unterdruecken von fuehrenden
0d54   b7da   sta $da             ;   Nullen setzen
0d56   2009   bra $0d61           ; und springen

0d58 : 3dda   tst $da             ; ist Merker zum Unterdruecken von
0d5a   2705   beq $0d61           ;   fuehrenden Nullen gesetzt?
0d5c   ae30   ldx #$30            ; falls nein, weitermachen
0d5e   cd0c77 jsr $0c77           ; falls ja, eine "0" (#$30) ausgeben

0d61 : b6d9   lda $d9             ; Akku mit Zaehler laden
0d63   5f     clrx                ; $de:$df = #$1dd7 + #2*Zaehler
0d64   48     lsla                ; (Adresse in der Tabelle berechnen)
0d65   59     rolx                ; (genau wie oben)
0d66   abd7   add #$d7            ;
0d68   b7df   sta $df             ;
0d6a   9f     txa                 ;
0d6b   a91d   adc #$1d            ; ($56:$57) = Word von Adresse ($de:$df)
0d6d   b7de   sta $de             ; (Word aus Tabelle holen)
0d6f   ae56   ldx #$56            ; (genau wie oben)
0d71   cd1cc9 jsr $1cc9           ;
0d74   ae00   ldx #$00            ; die zu uebertragende Zahl (steht auf
0d76   bfde   stx $de             ;   Adresse $00d0) durch den Wert auf
0d78   aed0   ldx #$d0            ;   $56:57 teilen und Modulo-Wert auf
0d7a   bfdf   stx $df             ;   $00d0 zurueckliefern
0d7c   cd1c95 jsr $1c95           ;
0d7f   3cd9   inc $d9             ; Zaehler inkrementieren

0d81 : b6d9   lda $d9             ; Schleife solange durchlaufen wie
0d83   a105   cmp #$05            ; Zaehler < #5 ist
0d85   2587   blo $0d0e           ;
0d87   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Unexplored byte
; ---------------------------------------------------------------------------

0d88 : d3     db $d3              ; %11010011

; ---------------------------------------------------------------------------
;      Adresszaehler fuer sequentielle EEPROM-Zugriffe des Mikrokontrollers
;      setzen
;
;      input : $d3:$d4 = neue Adresse
;      output: $66:$67 = Adresszaehler
;      used  : a,$66,$67
;
;      called from $0af6,$1a98,$1ab3
; ---------------------------------------------------------------------------

0d89 : b6d3   lda $d3             ; load accu with value at address $d3
0d8b   b766   sta $66             ; store accumulator at address $66
0d8d   b6d4   lda $d4             ; load accu with value at address $d4
0d8f   b767   sta $67             ; store accumulator at address $67
0d91   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer RS232-Befehl ASCII-Code 2 - Byte ins serielle EEPROM schreiben
;      EEPROM mit Adresszaehler im Mikrokontroller laden, anschliessend
;      Byte ins EEPROM (mit abschliessendem STOP-Signal) uebertragen und
;      Adresszaehler im Mikrokontroller inkrementieren
;
;      input : x=Byte, $66:$67=EEPROM-Adresse
;      output: $66:$67 inkrementiert
;      used  : a,x,$0(%00000011),$4(%00000001),$66-$67,$d1,$e1
;
;      called from $0aff,$0b0d,$0b16,$0b1a,$0b25
; ---------------------------------------------------------------------------

0d92 : bfd1   stx $d1             ; x auf $d1 speichern
0d94   aea0   ldx #$a0            ; Schreibkennung des EEPROMs
0d96   cd083c jsr $083c           ; EEPROM auf Eingabe schalten
0d99   be66   ldx $66             ;
0d9b   cd0846 jsr $0846           ; EEPROM-Adresse Highbyte uebertragen
0d9e   be67   ldx $67             ;
0da0   cd0846 jsr $0846           ; EEPROM-Adresse Lowbyte uebertragen
0da3   bed1   ldx $d1             ;
0da5   cd0846 jsr $0846           ; Byte zum EEPROM schicken
0da8   cd08e5 jsr $08e5           ; STOP-Signal zum EEPROM
0dab   3c67   inc $67             ;
0dad   2602   bne $0db1           ; und EEPROM-Adressenzaehler im
0daf   3c66   inc $66             ; Mikrokontroller inkrementieren
0db1 : 81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Unexplored byte
; ---------------------------------------------------------------------------

0db2 : d3     db $d3              ; %11010011

; ---------------------------------------------------------------------------
;      fuer CLOSE# und PRINT# - Word zum seriellen EEPROM senden
;      Speichert zwei Byte ab einer bestimmten EEPROM-Adresse
;
;      input : $d3:$d4=Word, $66:$67=EEPROM-Adresse
;      output: $66:$67 um zwei inkrementiert
;      used  : a,x,$0(%00000011),$4(%00000001),$66-$67,$d5-$d6,$e1
;
;      called from $1aa3,$1abe
; ---------------------------------------------------------------------------

0db3 : b6d3   lda $d3             ; $d5:$d6 = $d3:$d4
0db5   b7d5   sta $d5             ;
0db7   b6d4   lda $d4             ;
0db9   b7d6   sta $d6             ;
0dbb   aea0   ldx #$a0            ; Schreibkennung des EEPROMs
0dbd   cd083c jsr $083c           ; EEPROM auf Eingabe schalten
0dc0   be66   ldx $66             ;
0dc2   cd0846 jsr $0846           ; EEPROM-Adresse Highbyte uebertragen
0dc5   be67   ldx $67             ;
0dc7   cd0846 jsr $0846           ; EEPROM-Adresse Lowbyte uebertragen
0dca   bed5   ldx $d5             ;
0dcc   cd0846 jsr $0846           ; Highbyte zum EEPROM schicken
0dcf   bed6   ldx $d6             ;
0dd1   cd0846 jsr $0846           ; Lowbyte zum EEPROM schicken
0dd4   cd08e5 jsr $08e5           ; STOP-Signal zum EEPROM
0dd7   b667   lda $67             ;
0dd9   ab02   add #$02            ;
0ddb   b767   sta $67             ;
0ddd   b666   lda $66             ; und EEPROM-Adressenzaehler im
0ddf   a900   adc #$00            ; Mikrokontroller um zwei inkrementieren
0de1   b766   sta $66             ;
0de3   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Unexplored byte
; ---------------------------------------------------------------------------

0de4 : d3     db $d3              ; %11010011

; ---------------------------------------------------------------------------
;      Adresszaehler fuer sequentielle EEPROM-Zugriffe im Mikrokontroller
;      und im EEPROM setzen (der Counter entspricht u.a. dem BASIC-PC und
;      dem Adresszaehler fuer die Datendatei)
;
;      input : $d3,$d4 = neue EEPROM-Adresse
;      output: $66:$67 = Adresszaehler im Mikrokontroller
;      used  : a,x,$0(%00000011),$4(%00000001),$66-$67,$e1
;
;      called from $08fb,$0b48,$0b7e,$15dd,$15f8,$161a,$169a,$16b7,$16d0,
;                  $16e9,$1702,$17eb,$1803,$19a8,$1a07,$1a1c,$1a2a,$1a4e,
;                  $1a6f,$1ae0,$1b48
; ---------------------------------------------------------------------------

0de5 : b6d3   lda $d3             ; BASIC-PC Highbyte nach $66
0de7   b766   sta $66             ;
0de9   b6d4   lda $d4             ; BASIC-PC Lowbyte nach $67
0deb   b767   sta $67             ;
0ded   aea0   ldx #$a0            ; Schreibkennung fuer EEPROM
0def   cd083c jsr $083c           ; EEPROM auf Eingabe schalten
0df2   be66   ldx $66             ;
0df4   cd0846 jsr $0846           ; BASIC-PC Highbyte zum EEPROM
0df7   be67   ldx $67             ;
0df9   cd0846 jsr $0846           ; BASIC-PC Lowbyte zum EEPROM
0dfc   aea1   ldx #$a1            ; Lesekennung fuer EEPROM
0dfe   cc083c jmp $083c           ; EEPROM auf Ausgabe schalten

; ---------------------------------------------------------------------------
;      Sequentielles Lesen vom EEPROM beenden
;
;      input : -
;      output: -
;      used  : $0(%00000011),$4(%00000001)
;
;      called from $0917,$0b52,$0b9c,$15d2,$15ed,$160f,$168f,$16ac,$16c5,
;                  $16de,$16f7,$17d9,$17f8,$1989,$19fc,$1a11,$1a40,$1a5d,
;                  $1a85,$1aea,$1b68
; ---------------------------------------------------------------------------

0e01 : cc08bb jmp $08bb           ; unconditional jump to address $08bb

; ---------------------------------------------------------------------------
;      Hole ein Byte aus dem externen, seriellen EEPROM und inkrementiere
;      den im Mikrokontroller befindlichen Pointer, damit der Kontroller
;      weiss, welchen Wert der interne Pointer im EEPROM hat.
;      (sequentielles Lesen ohne Uebermittlung der Adresse)
;
;      input : [$66:$67=synchronlaufender EEPROM-Adressenzaehler]
;      output: a=Byte, $66:$67 inkrementiert
;      used  : a,x,$0(%00000011),$4(%00000001),$66-$67
;
;      called from $090e,$0b83,$0e0d,$0e11,$161f,$1628,$1631,$1640,$1714,
;                  $1720,$172b,$1744,$174f,$1761,$1773,$177a,$1781,$1788,
;                  $178f,$17a0,$17a7,$17ae,$17b5,$17bc,$17c3,$1806,$1881,
;                  $18e5,$1900,$197c,$19df
; ---------------------------------------------------------------------------

0e04 : 3c67   inc $67             ; increment at address $67
0e06   2602   bne $0e0a           ; branch if not equal (Z is clear)
0e08   3c66   inc $66             ; increment at address $66
0e0a : cc086f jmp $086f           ; unconditional jump to address $086f

; ---------------------------------------------------------------------------
;      Hole ein Word aus dem externen, seriellen EEPROM und inkrementiere
;      den im Mikrokontroller befindlichen Pointer, damit der Kontroller
;      weiss, welchen Wert der interne Pointer im EEPROM hat.
;      (sequentielles Lesen ohne Uebermittlung der Adresse)
;
;      input : [$66:$67=synchronlaufender EEPROM-Adressenzaehler]
;      output: x=$d3=highbyte, a=$d4=lowbyte, $66:67 um zwei inkrementiert
;      used  : a,x,$0(%00000011),$4(%00000001),$66-$67,$d3-$d4
;
;      called from $0b4b,$15cb,$15e0,$15fc,$169d,$170a,$1796,$17ca,$17ee,
;                  $19e6,$1a2d,$1a39,$1a51,$1a72,$1a7e,$1ae3,$1b4d
; ---------------------------------------------------------------------------

0e0d : adf5   bsr $0e04           ; branch to subroutine at address $0e04
0e0f   b7d3   sta $d3             ; store accumulator at address $d3
0e11   adf1   bsr $0e04           ; branch to subroutine at address $0e04
0e13   b7d4   sta $d4             ; store accumulator at address $d4
0e15   bed3   ldx $d3             ; load index reg. with value at addr. $d3
0e17   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      nach Reset die Speicherbereiche und Ports fuer die TIMER-Interrupts
;      initialisieren
;
;      input : -
;      output: -
;      used  : a,$0(%00010000),$4(%00010000),$9(%00100000),$12(%11000001),
;              $68-$7a,$7b(%00010001),$7c-$82,$85-$90
;
;      called from $094e
; ---------------------------------------------------------------------------

0e18 : 3f80   clr $80             ; HOUR (Stunde) auf null setzen
0e1a   3f81   clr $81             ; MINUTE (Minute) auf null setzen
0e1c   3f89   clr $89             ; SECOND (Sekunde) auf null setzen
0e1e   a603   lda #$03            ;
0e20   b76b   sta $6b             ; DOW (Wochentag) auf drei setzen
0e22   a601   lda #$01            ;
0e24   b76a   sta $6a             ; DAY (Tag) auf eins setzen
0e26   b782   sta $82             ; MONTH (Monat) auf eins setzen
0e28   a661   lda #$61            ;
0e2a   b790   sta $90             ; YEAR (Jahr) auf #97 setzen

0e2c   3f68   clr $68             ; Zeitzaehler fuer eine Sekunde loeschen
0e2e   3f69   clr $69             ;
0e30   3f6d   clr $6d             ; Zeitzaehler fuer letzte Zustandsaenderung
0e32   3f6e   clr $6e             ;   des DCF77-Signals loeschen

0e34   cd105b jsr $105b           ; Speicher fuer TIMERCAP-Interrupt loeschen

0e37   3f75   clr $75             ; Buffer fuer letzte empfangene DCF77-
0e39   3f76   clr $76             ;   Zeit loeschen
0e3b   3f77   clr $77             ;
0e3d   3f78   clr $78             ;
0e3f   3f79   clr $79             ;
0e41   3f7a   clr $7a             ;

0e43   117b   bclr #0,$7b         ; DCF77-OK-Bit loeschen
0e45   197b   bclr #4,$7b         ; TIME-SET-Bit loeschen
0e47   1804   bset #4,$04         ; DCF77-OK-LED-Pin auf Ausgang schalten
0e49   1800   bset #4,$00         ; DCF77-OK-LED ausschalten

0e4b   3f8a   clr $8a             ; TIMER auf null setzen
0e4d   3f8b   clr $8b             ;
0e4f   3f8e   clr $8e             ; Anzahl der PAUSE-Ticks loeschen
0e51   3f8f   clr $8f             ;
0e53   3f85   clr $85             ; Buffer fuer FREQ1 loeschen
0e55   3f86   clr $86             ;
0e57   3f87   clr $87             ; Buffer fuer FREQ2 loeschen
0e59   3f88   clr $88             ;
0e5b   3f7c   clr $7c             ; FREQ1 auf null setzen
0e5d   3f7d   clr $7d             ;
0e5f   3f7e   clr $7e             ; FREQ2 auf null setzen
0e61   3f7f   clr $7f             ;

0e63   1e12   bset #7,$12         ; enable input capture interrupt
0e65   1c12   bset #6,$12         ; enable output compare interrupt
0e67   1a09   bset #5,$09         ; enable A/D converter

0e69   3f8c   clr $8c             ; Halbe Periodendauer des BEEP-Signals
0e6b   3f8d   clr $8d             ;   auf Null setzen

0e6d   1112   bclr #0,$12         ; on output compare 1, TCMP1 will be low
0e6f   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer TIMERCMP-Interrupt: Routine TIMERCMP2
;      diese Routine wird bei jedem Timer compare interrupt 2 (also alle
;      20 Millisekunden) aufgerufen
;
;      Zuerst wird der naechste Aufrufzeitpunkt des Interrupts (in Abhaen-
;      gigkeit von der Prozessorgeschwindigkeit) festgelegt. Anschliessend
;      werden die DCF77-OK-Signale geloescht, wenn seit der letzten Zu-
;      standsaenderung des Signals mehr als 2 Sekunden vergangen sind.
;      Dann wird die interne Uhr eine Sekunde weitergezaehlt, falls der
;      interne Millisekundenzaehler das Ende einer Sekunde anzeigt.
;      Anschliessend wird die TIMER-Systemvariable um eins inkrementiert
;      und der Zaehler fuer die PAUSE-Ticks dekrementiert. Zum Schluss wird
;      das TEST-Signal am TCMP2-Pin erzeugt, indem das Output-level-2-Bit
;      getoggelt wird.
;
;      used  : a,x,$0(%00010000),$12(%00000100),$1e-$1f,$68-$6b,$6d-$6e,
;              $7b(%00000001),$7c-$8b,$8e-$90,$e3-$e4
;
;      called from $1d72
; ---------------------------------------------------------------------------

0e70 : 0b7b0c brclr #5,$7b,$0e7f  ; springe, falls SLOWMODE deaktiviert ist
0e73   b61f   lda $1f             ;
0e75   ab71   add #$71            ; $83:$84 = OCR2 + #625
0e77   b784   sta $84             ; (4 * 625 * 1/(2e6/16 Hz) = 20 ms)
0e79   b61e   lda $1e             ;
0e7b   a902   adc #$02            ;
0e7d   200a   bra $0e89           ; ueberspringen

0e7f : b61f   lda $1f             ;
0e81   ab10   add #$10            ; $83:$84 = OCR2 + #10000
0e83   b784   sta $84             ; (4 * 10000 * 1/(2e6 Hz) = 20 ms)
0e85   b61e   lda $1e             ;
0e87   a927   adc #$27            ;

0e89 : b783   sta $83             ;
0e8b   b71e   sta $1e             ; OCR2 = $83:$84
0e8d   b684   lda $84             ; (den Aufrufzeitpunkt fuer den nachsten
0e8f   b71f   sta $1f             ;   Timer compare interrupt 2 festlegen)

0e91   b66e   lda $6e             ; $6e:$6d = $6e:$6d + #20
0e93   ab14   add #$14            ; (Zeitzaehler fuer die Zustandsaenderung
0e95   b76e   sta $6e             ;   des DCF77-Signals um 20 ms erhoehen)
0e97   b66d   lda $6d             ;
0e99   a900   adc #$00            ;
0e9b   b76d   sta $6d             ;
0e9d   a107   cmp #$07            ; vergleiche $6d:$6e
0e9f   2604   bne $0ea5           ;
0ea1   b66e   lda $6e             ;
0ea3   a1d0   cmp #$d0            ; ist $6d:$6e kleiner oder gleich #2000?
0ea5 : 2304   bls $0eab           ; falls ja, ueberspringen
0ea7   117b   bclr #0,$7b         ; DCF77-OK-Bit loeschen
0ea9   1800   bset #4,$00         ; DCF77-OK-LED ausschalten

0eab : b669   lda $69             ; $68:$69 = $68:$69 + #20
0ead   ab14   add #$14            ; (Internen Millisekundenzaehler um 20 ms
0eaf   b769   sta $69             ;   erhoehen)
0eb1   b668   lda $68             ;
0eb3   a900   adc #$00            ;
0eb5   b768   sta $68             ;
0eb7   a103   cmp #$03            ; vergleiche $68:$69
0eb9   260d   bne $0ec8           ;
0ebb   b669   lda $69             ;
0ebd   a1e8   cmp #$e8            ;
0ebf   2607   bne $0ec8           ; springe, wenn $68:$69 ungleich #1000 ist
0ec1   3f68   clr $68             ; $68:$69 null setzen
0ec3   3f69   clr $69             ;
0ec5   cd106a jsr $106a           ; Uhr eine Sekunde weiterzaehlen

0ec8 : 3c8b   inc $8b             ; TIMER inkrementieren
0eca   2602   bne $0ece           ;
0ecc   3c8a   inc $8a             ;

0ece : b68e   lda $8e             ; ist $8e:$8f gleich null?
0ed0   ba8f   ora $8f             ; (wird kein PAUSE-Befehl ausgefuehrt?)
0ed2   270c   beq $0ee0           ; falls ja, ueberspringen
0ed4   b68f   lda $8f             ;
0ed6   a001   sub #$01            ; falls nein, $8e:$8f dekrementieren
0ed8   b78f   sta $8f             ; (PAUSE-Zeitzaehler dekrementieren)
0eda   b68e   lda $8e             ;
0edc   a200   sbc #$00            ; (siehe hierzu auch die Routine an
0ede   b78e   sta $8e             ;   der Adresse $10f7)

0ee0 : 051203 brclr #2,$12,$0ee6  ; springe, falls OLVL2 geloescht ist
0ee3   1512   bclr #2,$12         ; OLVL2 loeschen (TEST generieren)
0ee5   81     rts                 ; return from subroutine

0ee6 : 1412   bset #2,$12         ; OLVL2 setzen (TEST generieren)
0ee8   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer TIMERCMP-Interrupt: Routine TIMERCMP1
;      diese Routine wird bei jedem Timer compare interrupt 1 aufgerufen
;
;      Sie erzeugt einen Ton fuer den BEEP-Befehl, indem bei jedem Aufruf
;      das Output-level-1-Bit getoggelt und so eine Rechteckschwingung am
;      TCMP1-Pin generiert wird. Die Aufrufhaeufigkeit des Interrupts wird
;      durch das Word auf Adresse $8c:$8d festgelegt.
;
;           <---> halbe Periodendauer des Ausgangssignals, wird (in Pro-
;           _____       _____       _____        zessortakten) durch das
;          |     |     |     |     |     |       Word an Adresse $8c:$8d
;      ____|     |_____|     |_____|     |____   festgelegt
;
;
;      used  : a,$12(%00000001),$16-$17,$83-$84
;
;      called from $1d6e
; ---------------------------------------------------------------------------

0ee9 : b617   lda $17             ; $83:$84 = OCR1 + $8c:$8d
0eeb   bb8d   add $8d             ;
0eed   b784   sta $84             ;
0eef   b616   lda $16             ;
0ef1   b98c   adc $8c             ;
0ef3   b783   sta $83             ;
0ef5   b716   sta $16             ; OCR1 = $83:$84
0ef7   b684   lda $84             ;
0ef9   b717   sta $17             ;

0efb   b68c   lda $8c             ; ist $8c:$8d gleich null ?
0efd   ba8d   ora $8d             ;
0eff   2709   beq $0f0a           ; falls ja, beenden
0f01   011203 brclr #0,$12,$0f07  ; springe, falls OLVL1 geloescht ist
0f04   1112   bclr #0,$12         ; OLVL1 loeschen
0f06   81     rts                 ; return from subroutine

0f07 : 1012   bset #0,$12         ; OLVL1 setzen
0f09   81     rts                 ; return from subroutine

0f0a : 1112   bclr #0,$12         ; OLVL1 loeschen
0f0c   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer TIMERCAP-Interrupt: Routine DCF77_HIGH
;      wird bei jedem Timer Input Capture 1 Interrupt aufgerufen, der durch
;      eine positive Flanke des DCF77-Empfaengers (dem Ende einer Marke)
;      ausgeloest wurde und dekodiert LOW- und HIGH-Sekundenmarken
;
;             DCF77_LOW wird aufgerufen         Minutenende, wenn 1,8 - 1,9 s
;             ^ DCF77_HIGH wird aufgerufen      seit der letzten Zustands-
;             | ^                               aenderung vergangen sind
;             | |                               <------------->
;      ...____   _______   _______   _______    _______________   ____...
;             | |       | |       | |       |  |               | |
;             |_|       |_|       |_|       |__|               |_|
;               ^                              ^
;               LOW-Marke (100 ms)             HIGH-Marke (200 ms)
;               0         0         0          1                 0
;
;      DCF77-LOW-Sekundenmarken die kuerzer als 50 ms sind, werden vom
;      Betriebssystem einfach ignoriert (der Zahler fuer die Sekundenmarken
;      wird nicht weitergezaehlt).
;
;      used  : a,x,$0(%00010000),$6c-$74,$7b(%00000001)
;
;      called from $1d52
; ---------------------------------------------------------------------------

0f0d : b66d   lda $6d             ; ist $6d:$6e groesser oder gleich #900 ?
0f0f   a103   cmp #$03            ; (sind mehr als 900 ms seit der letzten
0f11   2604   bne $0f17           ;   Zustandsaenderung des DCF77-Signals
0f13   b66e   lda $6e             ;   vergangen?)
0f15   a184   cmp #$84            ;
0f17 : 241d   bhs $0f36           ; wenn ja (falsches DCF77-Signal), springe

0f19   b66d   lda $6d             ; ist $6d:$6e kleiner als #150 ?
0f1b   98     clc                 ; (sind weniger als 150 ms seit der letzten
0f1c   2604   bne $0f22           ;   Zustandsaenderung vergangen?)
0f1e   b66e   lda $6e             ;
0f20   a196   cmp #$96            ;
0f22 : 2503   blo $0f27           ; wenn ja (Lowmarker erkannt), springe

0f24   cd0fce jsr $0fce           ; DCF77-Highmarker dekodieren

0f27 : b66d   lda $6d             ; ist $6d:$6e kleiner als #50 ?
0f29   98     clc                 ; (LOW-Marker, die kuerzer als 50 ms
0f2a   2604   bne $0f30           ;   sind, werden ignoriert)
0f2c   b66e   lda $6e             ;
0f2e   a132   cmp #$32            ;
0f30 : 2509   blo $0f3b           ; wenn ja (Marker zu kurz), springe

0f32   3c6c   inc $6c             ; Zaehler fuer DCF77-Marker inkrementieren
0f34   2005   bra $0f3b           ; branch always to $0f3b

0f36 : cd105b jsr $105b           ; DCF77-Buffer loeschen
0f39   117b   bclr #0,$7b         ; DCF77-OK-Bit loeschen

0f3b : 3f6d   clr $6d             ; Zeitzaehler fuer Zustandsaenderung auf
0f3d   3f6e   clr $6e             ;   null setzen
0f3f   007b02 brset #0,$7b,$0f44  ; wenn DCF77-Signal noch nicht vollstaendig
0f42   1800   bset #4,$00         ;   gelesen: DCF77-OK-LED blinken lassen
0f44 : 81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer TIMERCAP-Interrupt: Routine DCF77_LOW
;      wird bei jedem Timer Input Capture 1 Interrupt aufgerufen, der durch
;      eine negative Flanke des DCF77-Empfaengers (den Beginn einer Marke)
;      ausgeloest wurde
;
;      Um festzustellen, ob beim Empfang und dem Dekodieren des DCF77-Signals
;      kein Fehler aufgetreten ist, wird die empfangene Zeit mit der vor
;      einer Minute verglichen, erst dann wird die Systemzeit nach der
;      DCF77-Zeit gestellt. Dummerweise funktioniert das aber nur bei
;      Uhrzeiten die sich nur in dem Minutenwert unterscheiden. Zur vollen
;      Stunde wird das DCF77-Signal deshalb immer als ungueltig erkannt!
;      Wenn der Mikrokontroller zu einem unguenstigen Zeitpunkt gestartet
;      wurde kann es also bis zu vier Minuten dauern, bis die Systemzeit
;      durch ein fehlerfrei empfangenes DCF77-Signal gestellt wird.
;
;      used  : a,$0(%00010000),$6a-$7a,$7b(%00010001),$80-$82,$85-$86,$89,
;              $90,$e2
;
;      called from $1d59
; ---------------------------------------------------------------------------

0f45 : 3c86   inc $86             ; Buffer fuer FREQ1 inkrementieren
0f47   2602   bne $0f4b           ;
0f49   3c85   inc $85             ;

0f4b : 007b02 brset #0,$7b,$0f50  ; wenn DCF77-Signal noch nicht vollstaendig
0f4e   1900   bclr #4,$00         ;   gelesen: DCF77-OK-LED blinken lassen

0f50 : b66d   lda $6d             ; ist $6d:$6e kleiner oder gleich #1100 ?
0f52   a104   cmp #$04            ; (wenn seit der letzten Zustandsaenderung
0f54   2604   bne $0f5a           ;   weniger als 1100 ms vergangen sind,
0f56   b66e   lda $6e             ;   wurde ein Sekunden-, kein Minuten-
0f58   a14c   cmp #$4c            ;   Marker empfangen)
0f5a : 236d   bls $0fc9           ; falls ja (Marker 00-58), springen

0f5c   b66d   lda $6d             ; ist $6d:$6e groesser oder gleich #2000 ?
0f5e   a107   cmp #$07            ; (wenn mehr als 2 Sekunden vergangen sind,
0f60   2604   bne $0f66           ;   wurde ein ungueltiges DCF77-Signal
0f62   b66e   lda $6e             ;   empfangen)
0f64   a1d0   cmp #$d0            ;
0f66 : 245a   bhs $0fc2           ; wenn ja (falsches DCF77-Signal), springen

0f68   b674   lda $74             ; Ansonsten sind seit der letzten Zusands-
0f6a   b07a   sub $7a             ;   aenderung zwischen 1100 und 2000 ms
0f6c   c700e2 sta >$00e2          ;   vergangen, d.h. das Minutenende (bzw.
0f6f   b66c   lda $6c             ;   der Minutenanfang) ist erreicht.
0f71   a13b   cmp #$3b            ;
0f73   262f   bne $0fa4           ; Falls jetzt der Zaehler fuer die DCF77-
0f75   b66f   lda $6f             ;   Marker ungleich 59 ist, dann wurde
0f77   b175   cmp $75             ;   das Signal unvollstaendig empfangen,
0f79   2629   bne $0fa4           ;   deshalb nach $fa4 springen und
0f7b   b670   lda $70             ;   ungueltiges Signal anzeigen.
0f7d   b176   cmp $76             ;
0f7f   2623   bne $0fa4           ;
0f81   b671   lda $71             ;
0f83   b177   cmp $77             ;
0f85   261d   bne $0fa4           ; Sonst das gerade empfangene Zeittele-
0f87   b672   lda $72             ;   gramm mit dem, das vor einer Minute
0f89   b178   cmp $78             ;   empfangen wurde, vergleichen.
0f8b   2617   bne $0fa4           ;
0f8d   b673   lda $73             ; Nur falls die gerade empfangene DCF77-
0f8f   b179   cmp $79             ;   Zeit gleich der vor einer Minute
0f91   2611   bne $0fa4           ;   empfangenen (mit um eins erhoehtem
0f93   c600e2 lda >$00e2          ;   Minutenwert) ist, wird die Systemzeit
0f96   4a     deca                ;   nach DCF77 gestellt, ansonsten wird
0f97   260b   bne $0fa4           ;   das DCF77-Signal als ungueltig erkannt.

0f99   cd1040 jsr $1040           ; Systemzeit nach DCF77 stellen
0f9c   1900   bclr #4,$00         ; DCF77-OK-LED einschalten
0f9e   107b   bset #0,$7b         ; DCF77-OK-Bit setzen
0fa0   187b   bset #4,$7b         ; TIME-SET-Bit setzen
0fa2   2004   bra $0fa8           ; branch always to $0fa8

0fa4 : 1800   bset #4,$00         ; DCF77-OK-LED ausschalten
0fa6   117b   bclr #0,$7b         ; DCF77-OK-Bit loeschen

0fa8 : b66f   lda $6f             ;
0faa   b775   sta $75             ; buffere die gerade empfangene, gueltige
0fac   b670   lda $70             ;   DCF77-Zeit im Speicherbereich zum
0fae   b776   sta $76             ;   Puffern des letzten Zeittelegramms
0fb0   b671   lda $71             ;
0fb2   b777   sta $77             ;
0fb4   b672   lda $72             ;
0fb6   b778   sta $78             ;
0fb8   b673   lda $73             ;
0fba   b779   sta $79             ;
0fbc   b674   lda $74             ;
0fbe   b77a   sta $7a             ;
0fc0   2004   bra $0fc6           ; branch always to $0fc6

0fc2 : 1800   bset #4,$00         ; DCF77-OK-LED ausschalten
0fc4   117b   bclr #0,$7b         ; DCF77-OK-Bit loeschen
0fc6 : cd105b jsr $105b           ; DCF77-Buffer loeschen
0fc9 : 3f6d   clr $6d             ; Zeitzaehler fuer Zustandsaenderung auf
0fcb   3f6e   clr $6e             ;   null setzen
0fcd   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Dekodierung einer einzelnen High-Marke des DCF77-Signals
;      wird von der Routine DCF77_HIGH des TIMERCAP-Interrupts benutzt
;
;      je nachdem, welche Marke high ist, wird die Wertigkeit aus der
;      Tabelle am Ende des ROMs gelesen und in den Buffer zum Errechnen
;      der DCF77-Zeit eingefuegt
;
;      input : $6c = Nummer der High-Marke, $6f-$74 = Buffer fuer DCF77-Zeit
;      output: $74=Minuten, $73=Stunden, $72=Wochentag, $71=Kalendertag
;              $70=Kalendermonat, $6f=Kalenderjahr
;      used  : a,x,$6f-$74
;
;      called from $0f24
; ---------------------------------------------------------------------------

0fce : b66c   lda $6c             ; Akku mit Inhalt der Adresse $6c laden
0fd0   a115   cmp #$15            ;
0fd2   250d   blo $0fe1           ; springe, wenn Akku kleiner #21 ist
0fd4   a11b   cmp #$1b            ;
0fd6   2209   bhi $0fe1           ; springe, wenn Akku groesser #27 ist
0fd8   97     tax                 ; x = a
0fd9   d61dd9 lda $1dee-21,x      ; Byte aus Tabelle holen und
0fdc   bb74   add $74             ; auf $74 aufaddieren
0fde   b774   sta $74             ;
0fe0   81     rts                 ; return from subroutine

0fe1 : b66c   lda $6c             ; Akku mit Inhalt der Adresse $6c laden
0fe3   a11d   cmp #$1d            ;
0fe5   250d   blo $0ff4           ; springe, wenn Akku kleiner #29 ist
0fe7   a122   cmp #$22            ;
0fe9   2209   bhi $0ff4           ; springe, wenn Akku groesser #34 ist
0feb   97     tax                 ; x = a
0fec   d61dd1 lda $1dee-29,x      ; Byte aus Tabelle holen und
0fef   bb73   add $73             ; auf $73 aufaddieren
0ff1   b773   sta $73             ;
0ff3   81     rts                 ; return from subroutine

0ff4 : b66c   lda $6c             ; Akku mit Inhalt der Adresse $6c laden
0ff6   a124   cmp #$24            ;
0ff8   250d   blo $1007           ; springe, wenn Akku kleiner #36 ist
0ffa   a129   cmp #$29            ;
0ffc   2209   bhi $1007           ; springe, wenn Akku groesser #41 ist
0ffe   97     tax                 ; x = a
0fff   d61dca lda $1dee-36,x      ; Byte aus Tabelle holen und
1002   bb71   add $71             ; auf $71 aufaddieren
1004   b771   sta $71             ;
1006   81     rts                 ; return from subroutine

1007 : b66c   lda $6c             ; Akku mit Inhalt der Adresse $6c laden
1009   a12a   cmp #$2a            ;
100b   250d   blo $101a           ; springe, wenn Akku kleiner #42 ist
100d   a12c   cmp #$2c            ;
100f   2209   bhi $101a           ; springe, wenn Akku groesser #44 ist
1011   97     tax                 ; x = a
1012   d61dc4 lda $1dee-42,x      ; Byte aus Tabelle holen und
1015   bb72   add $72             ; auf $72 aufaddieren
1017   b772   sta $72             ;
1019   81     rts                 ; return from subroutine

101a : b66c   lda $6c             ; Akku mit Inhalt der Adresse $6c laden
101c   a12d   cmp #$2d            ;
101e   250d   blo $102d           ; springe, wenn Akku kleiner #45 ist
1020   a131   cmp #$31            ;
1022   2209   bhi $102d           ; springe, wenn Akku groesser #49 ist
1024   97     tax                 ; x = a
1025   d61dc1 lda $1dee-45,x      ; Byte aus Tabelle holen und
1028   bb70   add $70             ; auf $70 aufaddieren
102a   b770   sta $70             ;
102c   81     rts                 ; return from subroutine

102d : b66c   lda $6c             ; Akku mit Inhalt der Adresse $6c laden
102f   a132   cmp #$32            ;
1031   250c   blo $103f           ; springe, wenn Akku kleiner #50 ist
1033   a139   cmp #$39            ;
1035   2208   bhi $103f           ; springe, wenn Akku groesser #57 ist
1037   97     tax                 ; x = a
1038   d61dbc lda $1dee-50,x      ; Byte aus Tabelle holen und
103b   bb6f   add $6f             ; auf $6f aufaddieren
103d   b76f   sta $6f             ;
103f : 81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Die Systemzeit nach dem empfangenen DCF77-Zeittelegramm stellen
;      wird von der Routine DCF77_LOW des TIMERCAP-Interrupts aufgerufen
;
;      input : $6f-$74 = Buffer fuer DCF77-Uhrzeit und Datum
;      output: $6a-$6b,$80-$82,$89,$90 = Systemzeit
;      used  : a,$6a-$6b,$80-$82,$89,$90
;
;      called from $0f99
; ---------------------------------------------------------------------------

1040 : b66f   lda $6f             ; load accu with value at address $6f
1042   b790   sta $90             ; store accumulator at address $90
1044   b670   lda $70             ; load accu with value at address $70
1046   b782   sta $82             ; store accumulator at address $82
1048   b671   lda $71             ; load accu with value at address $71
104a   b76a   sta $6a             ; store accumulator at address $6a
104c   b672   lda $72             ; load accu with value at address $72
104e   b76b   sta $6b             ; store accumulator at address $6b
1050   b673   lda $73             ; load accu with value at address $73
1052   b780   sta $80             ; store accumulator at address $80
1054   b674   lda $74             ; load accu with value at address $74
1056   b781   sta $81             ; store accumulator at address $81
1058   3f89   clr $89             ; clear memory at address $89
105a   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Buffer zum Empfangen des DCF77-Zeittelegramms loeschen
;      wird nach einem Reset und von den beiden TIMERCAP-Interrupt-Routinen
;      DCF77_HIGH und DCF77_LOW aufgerufen
;
;      input : -
;      output: -
;      used  : $6c,$6f-$74
;
;      called from $0e34,$0f36,$0fc6
; ---------------------------------------------------------------------------

105b : 3f6f   clr $6f             ; clear memory at address $6f
105d   3f70   clr $70             ; clear memory at address $70
105f   3f71   clr $71             ; clear memory at address $71
1061   3f72   clr $72             ; clear memory at address $72
1063   3f73   clr $73             ; clear memory at address $73
1065   3f74   clr $74             ; clear memory at address $74
1067   3f6c   clr $6c             ; clear memory at address $6c
1069   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Systemuhr eine Sekunde weiterzaehlen und FREQ1 und FREQ2 speichern
;      wird von der Routine TIMERCMP2 des TIMERCMP-Interrupts einmal pro
;      Sekunde aufgerufen
;
;      Der Code zur Ermittlung eines Schaltjahres hat einen Bug (was u.U.
;      am verwendeten C-Compiler liegt)! Dummerweise funktioniert der
;      verwendete Algorithmus sogar einmal: naemlich genau dann, wenn YEAR
;      gleich null ist; also im Jahr 2000. Somit liefert der Chip immerhin
;      bis zum 28. Februar 2004 selbststaendig das richtige Datum (danach
;      muss alle vier Jahre von Hand nachgestellt werden).
;
;      Ein weiterer Bug steckt im Weiterzaehlen des Wochentags: Es wird
;      nicht wie erwartet von 0 bis 6, sondern von 0 bis 7 gezaehlt; was
;      wohl falsch ist, denn jede Woche hat genau 7 und nie 8 Tage.
;
;      used  : a,x,$6a-$6b,$7c-$82,$85-$89,$90,$e3-$e4
;
;      called from $0ec5
; ---------------------------------------------------------------------------

106a : b685   lda $85             ; FREQ1 = $85:$86
106c   b77c   sta $7c             ;
106e   b686   lda $86             ;
1070   b77d   sta $7d             ;
1072   3f85   clr $85             ; $85:$86 = #0
1074   3f86   clr $86             ;
1076   b687   lda $87             ; FREQ2 = $87:$88
1078   b77e   sta $7e             ;
107a   b688   lda $88             ;
107c   b77f   sta $7f             ;
107e   3f87   clr $87             ; $87:$88 = #0
1080   3f88   clr $88             ;

1082   3c89   inc $89             ; SECOND inkrementieren
1084   b689   lda $89             ;
1086   a13c   cmp #$3c            ;
1088   266b   bne $10f5           ; beenden, falls ungleich #60
108a   3f89   clr $89             ; SECOND auf null setzen
108c   3c81   inc $81             ;
108e   b681   lda $81             ; MINUTE inkrementieren
1090   a13c   cmp #$3c            ;
1092   2661   bne $10f5           ; beenden, falls ungleich #60
1094   3f81   clr $81             ; MINUTE auf null setzen
1096   3c80   inc $80             ;
1098   b680   lda $80             ; HOUR inkrementieren
109a   a118   cmp #$18            ;
109c   2657   bne $10f5           ; beenden, falls ungleich #24
109e   3f80   clr $80             ; HOUR auf null setzen
10a0   3c6a   inc $6a             ; DAY inkrementieren
10a2   3c6b   inc $6b             ; DOW inkrementieren
10a4   b66b   lda $6b             ;
10a6   a108   cmp #$08            ; (#7 WAERE BESSER!)
10a8   2602   bne $10ac           ; ueberspringen, falls ungleich #8
10aa   3f6b   clr $6b             ; falls gleich, DOW auf null setzen
10ac : be82   ldx $82             ; MONTH laden
10ae   de1de1 ldx $1de1,x         ; x = Anzahl der Tage in MONTH
10b1   cf00e3 stx >$00e3          ; auf Adresse $e3 speichern
10b4   b682   lda $82             ; MONTH laden
10b6   a102   cmp #$02            ;
10b8   261a   bne $10d4           ; ueberspringen, falls ungleich #2

10ba   b690   lda $90             ; YEAR laden
10bc   44     lsra                ;
10bd   44     lsra                ; durch vier teilen
10be   c700e4 sta >$00e4          ; \ diese beiden Befehle verursachen den
10c1   b690   lda $90             ; / Schaltjahr-Bug
10c3   48     lsla                ;
10c4   48     lsla                ; mit vier multiplizieren
10c5   c700e4 sta >$00e4          ; und auf Adresse $e4 speichern
10c8   b690   lda $90             ; YEAR laden
10ca   c100e4 cmp >$00e4          ;
10cd   2605   bne $10d4           ; springe, falls YEAR <> $e4 ist
10cf   a61d   lda #$1d            ; (KLAPPT NUR IM JAHR 2000!)
10d1   c700e3 sta >$00e3          ; falls gleich, #29 auf $e3 speichern

10d4 : b66a   lda $6a             ; DAY laden
10d6   c100e3 cmp >$00e3          ;
10d9   231a   bls $10f5           ; beenden, falls DAY kleiner/gleich $e3 ist
10db   a601   lda #$01            ;
10dd   b76a   sta $6a             ; DAY auf eins setzen
10df   3c82   inc $82             ; MONTH inkrementieren
10e1   b682   lda $82             ;
10e3   a10d   cmp #$0d            ;
10e5   260e   bne $10f5           ; beenden, falls ungleich #13
10e7   a601   lda #$01            ;
10e9   b782   sta $82             ; MONTH auf eins setzen
10eb   3c90   inc $90             ; YEAR inkrementieren
10ed   b690   lda $90             ;
10ef   a164   cmp #$64            ;
10f1   2602   bne $10f5           ; beenden, falls YEAR <> #100 ist
10f3   3f90   clr $90             ; YEAR auf null setzen

10f5 : 81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Unexplored byte
; ---------------------------------------------------------------------------

10f6 : ce     db $ce              ; %11001110

; ---------------------------------------------------------------------------
;      fuer BASIC Token 2 - PAUSE
;      stoppt den Prozessor eine gewisse Zeit lang
;
;      Die gewuenschte Anzahl von 20 ms Einheiten, die gewartet werden sollen
;      werden von dieser Routine auf Adresse $8e:$8f geschrieben. Das Word
;      an dieser Adresse wird vom Betriebssystem innerhalb des TIMERCMP-
;      Interrupts alle 20 Millisekunden bis auf null dekrementiert, so dass
;      das Ende des Wartezyklus' recht elegant detektiert werden kann.
;
;      input : $ce:$cf = Anzahl der 20 ms Einheiten
;      output: -
;      used  : a,$8e,$8f
;
;      called from $15c5
; ---------------------------------------------------------------------------

10f7 : 9b     sei                 ; set interrupt mask (disable interrupts)
10f8   b6ce   lda $ce             ; load accu with value at address $ce
10fa   b78e   sta $8e             ; store accumulator at address $8e
10fc   b6cf   lda $cf             ; load accu with value at address $cf
10fe   b78f   sta $8f             ; store accumulator at address $8f
1100   9a     cli                 ; clear interrupt mask (enable interrupts)
1101   2001   bra $1104           ; branch always to $1104

1103 : 8f     wait                ; enable interrupts & wait for interrupt
1104 : b68e   lda $8e             ; load accu with value at address $8e
1106   ba8f   ora $8f             ; OR accu with value at address $8f
1108   26f9   bne $1103           ; branch if not equal (Z is clear)
110a   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer BASIC Token 9 b - SLOWMODE
;      Takt auf 1/16 verringern (125 kHz intern)
;
;      input : -
;      output: -
;      used  : $c(%00000010),$7b(%00100000)
;
;      jumped from $171a
; ---------------------------------------------------------------------------

110b : 9b     sei                 ; set interrupt mask (disable interrupts)
110c   1a7b   bset #5,$7b         ; set bit #5 at memory address $7b
110e   120c   bset #1,$0c         ; set bit #1 at memory address $0c
1110   9a     cli                 ; clear interrupt mask (enable interrupts)
1111   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer BASIC Token 9 b - SLOWMODE
;      normale Taktrate aktivieren (2 MHz intern)
;
;      input : -
;      output: -
;      used  : $c(%00000010),$7b(%00100000)
;
;      jumped from $171d
; ---------------------------------------------------------------------------

1112 : 9b     sei                 ; set interrupt mask (disable interrupts)
1113   1b7b   bclr #5,$7b         ; clear bit #5 at memory address $7b
1115   130c   bclr #1,$0c         ; clear bit #1 at memory address $0c
1117   9a     cli                 ; clear interrupt mask (enable interrupts)
1118   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Unexplored byte
; ---------------------------------------------------------------------------

1119 : d0     db $d0              ; %11010000

; ---------------------------------------------------------------------------
;      fuer BASIC Token 29 b - internes BASIC-Kommando
;      TICKS (z.B. fuer BEEP-Befehl) setzen
;
;      Mit dieser Routine kann die Aufrufhaeufigkeit des Timer Compare 1
;      Interrupts, und somit die Tonhoehe des BEEP-Ausgangssignals fest-
;      gelegt werden.
;
;      input : $d0:$d1 = halbe Periodendauer des Ausgangssignals (oder 0)
;      output: -
;      used  : a,$12(%00000001),$16-$17,$54-$55,$83-$84,$8c-$8d
;
;      called from $18cf
; ---------------------------------------------------------------------------

111a : 9b     sei                 ; set interrupt mask (disable interrupts)

111b   b6d0   lda $d0             ; $8c:$8d = $d0:$d1
111d   b78c   sta $8c             ;
111f   b6d1   lda $d1             ;
1121   b78d   sta $8d             ;
1123   b68c   lda $8c             ;
1125   ba8d   ora $8d             ; ist $8c:$8d = #0 ?
1127   2728   beq $1151           ; wenn ja, beenden

1129   0b7b09 brclr #5,$7b,$1135  ; springe, wenn SLOWMODE deaktiv ist
112c   a604   lda #$04            ;
112e : 348c   lsr $8c             ; $8c:$8d durch 16 teilen
1130   368d   ror $8d             ;
1132   4a     deca                ;
1133   26f9   bne $112e           ;

1135 : b618   lda $18             ; $54:$55 = TR (Timer counter register)
1137   b754   sta $54             ;
1139   b619   lda $19             ;
113b   b755   sta $55             ;
113d   bb8d   add $8d             ; $83:$84 = $54:$55 + $8c:$8d
113f   b784   sta $84             ;
1141   b654   lda $54             ;
1143   b98c   adc $8c             ;
1145   b783   sta $83             ;
1147   b716   sta $16             ; OCR1 = $83:$84
1149   b684   lda $84             ;
114b   b717   sta $17             ;
114d   1012   bset #0,$12         ; OLVL1 setzen
114f   2002   bra $1153           ; beenden

1151 : 1112   bclr #0,$12         ; OLVL1 loeschen
1153 : 9a     cli                 ; clear interrupt mask (enable interrupts)
1154   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      TIMER-Variable lesen
;
;      input : [$8a:$8b = TIMER]
;      output: x = highbyte, a = lowbyte
;      used  : a,x
;
;      called from $1448,$1854
; ---------------------------------------------------------------------------

1155 : 9b     sei                 ; set interrupt mask (disable interrupts)
1156   be8a   ldx $8a             ; load index reg. with value at addr. $8a
1158   b68b   lda $8b             ; load accu with value at address $8b
115a   9a     cli                 ; clear interrupt mask (enable interrupts)
115b   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      FREQ1-Variable lesen
;
;      input : [$7c:$7d = FREQ1]
;      output: x = highbyte, a = lowbyte
;      used  : a,x
;
;      called from $1861
; ---------------------------------------------------------------------------

115c : 9b     sei                 ; set interrupt mask (disable interrupts)
115d   be7c   ldx $7c             ; load index reg. with value at addr. $7c
115f   b67d   lda $7d             ; load accu with value at address $7d
1161   9a     cli                 ; clear interrupt mask (enable interrupts)
1162   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      FREQ2-Variable lesen
;
;      input : [$7e:$7f = FREQ2]
;      output: x = highbyte, a = lowbyte
;      used  : a,x
;
;      called from $1866
; ---------------------------------------------------------------------------

1163 : 9b     sei                 ; set interrupt mask (disable interrupts)
1164   be7e   ldx $7e             ; load index reg. with value at addr. $7e
1166   b67f   lda $7f             ; load accu with value at address $7f
1168   9a     cli                 ; clear interrupt mask (enable interrupts)
1169   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Rechenstack ($91..$9e) loeschen
;
;      input : -
;      output: -
;      used  : $91-$9e
;
;      called from $0960,$15b8
; ---------------------------------------------------------------------------

116a : 3f9e   clr $9e             ; clear memory at address $9e
116c   3f9d   clr $9d             ; clear memory at address $9d
116e   3f9c   clr $9c             ; clear memory at address $9c
1170   3f9b   clr $9b             ; clear memory at address $9b
1172   3f9a   clr $9a             ; clear memory at address $9a
1174   3f99   clr $99             ; clear memory at address $99
1176   3f98   clr $98             ; clear memory at address $98
1178   3f97   clr $97             ; clear memory at address $97
117a   3f96   clr $96             ; clear memory at address $96
117c   3f95   clr $95             ; clear memory at address $95
117e   3f94   clr $94             ; clear memory at address $94
1180   3f93   clr $93             ; clear memory at address $93
1182   3f91   clr $91             ; clear memory at address $91
1184   3f92   clr $92             ; clear memory at address $92
1186   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Platz auf Stack schaffen ($91,$92 -> $93,$94, usw.)
;
;      input : -
;      output: -
;      used  : a,$93-$9e
;
;      called from $1212,$1228,$1237,$1248,$125c,$1267
; ---------------------------------------------------------------------------

1187 : b69b   lda $9b             ; load accu with value at address $9b
1189   b79d   sta $9d             ; store accumulator at address $9d
118b   b69c   lda $9c             ; load accu with value at address $9c
118d   b79e   sta $9e             ; store accumulator at address $9e
118f   b699   lda $99             ; load accu with value at address $99
1191   b79b   sta $9b             ; store accumulator at address $9b
1193   b69a   lda $9a             ; load accu with value at address $9a
1195   b79c   sta $9c             ; store accumulator at address $9c
1197   b697   lda $97             ; load accu with value at address $97
1199   b799   sta $99             ; store accumulator at address $99
119b   b698   lda $98             ; load accu with value at address $98
119d   b79a   sta $9a             ; store accumulator at address $9a
119f   b695   lda $95             ; load accu with value at address $95
11a1   b797   sta $97             ; store accumulator at address $97
11a3   b696   lda $96             ; load accu with value at address $96
11a5   b798   sta $98             ; store accumulator at address $98
11a7   b693   lda $93             ; load accu with value at address $93
11a9   b795   sta $95             ; store accumulator at address $95
11ab   b694   lda $94             ; load accu with value at address $94
11ad   b796   sta $96             ; store accumulator at address $96
11af   b691   lda $91             ; load accu with value at address $91
11b1   b793   sta $93             ; store accumulator at address $93
11b3   b692   lda $92             ; load accu with value at address $92
11b5   b794   sta $94             ; store accumulator at address $94
11b7   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Stack poppen, dabei Top-Of-Stack ($91,$92) unbeeinflusst lassen,
;      das vorletzte Word wird vom Vor-vorletzten ueberschrieben
;
;      Diese Routine wird immer dann aufgerufen, wenn mit den letzten beiden
;      Eintraegen auf dem Rechenstack eine Operation durchgefuehrt, und das
;      Ergebnis der Operation (wie im CCBASIC-Betriebssystem allgemein
;      ueblich) bereits auf dem Stack abgespeichert wurde. Der vorletzte
;      Eintrag wird vom Stack entfernt.
;
;      input : -
;      output: -
;      used  : a,$93-$9c
;
;      jumped from $12cf,$12e2,$12f5,$1313,$1331,$134e,$135d,$137b,$1399,
;                  $13b7,$14a1,$14c1,$14e0,$14e7,$1506,$150d,$1529,$1533,
;                  $154f,$1559,$156f,$1576,$1589,$1593
; ---------------------------------------------------------------------------

11b8 : b695   lda $95             ; load accu with value at address $95
11ba   b793   sta $93             ; store accumulator at address $93
11bc   b696   lda $96             ; load accu with value at address $96
11be   b794   sta $94             ; store accumulator at address $94
11c0   b697   lda $97             ; load accu with value at address $97
11c2   b795   sta $95             ; store accumulator at address $95
11c4   b698   lda $98             ; load accu with value at address $98
11c6   b796   sta $96             ; store accumulator at address $96
11c8   b699   lda $99             ; load accu with value at address $99
11ca   b797   sta $97             ; store accumulator at address $97
11cc   b69a   lda $9a             ; load accu with value at address $9a
11ce   b798   sta $98             ; store accumulator at address $98
11d0   b69b   lda $9b             ; load accu with value at address $9b
11d2   b799   sta $99             ; store accumulator at address $99
11d4   b69c   lda $9c             ; load accu with value at address $9c
11d6   b79a   sta $9a             ; store accumulator at address $9a
11d8   b69d   lda $9d             ; load accu with value at address $9d
11da   b79b   sta $9b             ; store accumulator at address $9b
11dc   b69e   lda $9e             ; load accu with value at address $9e
11de   b79c   sta $9c             ; store accumulator at address $9c
11e0   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      nach Reset die 24 Userbytes ab Adresse $a1 loeschen
;
;      input : -
;      output: -
;      used  : a,x,$54,[$a1-$b8]
;
;      called from $095d
; ---------------------------------------------------------------------------

11e1 : 3f54   clr $54             ; clear memory at address $54
11e3   2007   bra $11ec           ; branch always to $11ec

11e5 : 4f     clra                ; clear accumulator
11e6   be54   ldx $54             ; load index reg. with value at addr. $54
11e8   e7a1   sta $a1,x           ; store accumulator at address $a1 + x-reg.
11ea   3c54   inc $54             ; increment at address $54
11ec : b654   lda $54             ; load accu with value at address $54
11ee   a118   cmp #$18            ; compare accumulator with value #$18
11f0   25f3   blo $11e5           ; branch if accu is lower (C is set)
11f2   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer BASIC Token 21 b - internes BASIC-Kommando
;      eine User-Bitvariable auf den Stack pushen
;
;      input : x = Nummer der Bitvariablen (0..191), $a1..$b8
;      output: -
;      used  : a,x,$54,$55,$56,$91-$9e
;
;      jumped from $17a4
; ---------------------------------------------------------------------------

11f3 : 9f     txa                 ; transfer index register to accumulator
11f4   44     lsra                ; logical shift right accumulator
11f5   44     lsra                ; logical shift right accumulator
11f6   44     lsra                ; logical shift right accumulator
11f7   b756   sta $56             ; store accumulator at address $56
11f9   9f     txa                 ; transfer index register to accumulator
11fa   a407   and #$07            ; AND accu with value #$07
11fc   b755   sta $55             ; store accumulator at address $55
11fe   97     tax                 ; transfer accumulator to index register
11ff   a601   lda #$01            ; load accumulator with value #$01
1201   5d     tstx                ; test index register for negative or zero
1202   2704   beq $1208           ; branch if equal (Z is set)
1204 : 48     lsla                ; shift left accumulator
1205   5a     decx                ; decrement index register
1206   26fc   bne $1204           ; branch if not equal (Z is clear)
1208 : b754   sta $54             ; store accumulator at address $54
120a   be56   ldx $56             ; load index reg. with value at addr. $56
120c   e6a1   lda $a1,x           ; load accu with value at addr. $a1 + x-reg.
120e   b454   and $54             ; AND accu with value at address $54
1210   b754   sta $54             ; store accumulator at address $54
1212   cd1187 jsr $1187           ; jump to subroutine at address $1187
1215   3d54   tst $54             ; test for negative or zero at address $54
1217   2708   beq $1221           ; branch if equal (Z is set)
1219   aeff   ldx #$ff            ; load index register with value #$ff
121b   9f     txa                 ; transfer index register to accumulator
121c   b792   sta $92             ; store accumulator at address $92
121e   bf91   stx $91             ; store index register at address $91
1220   81     rts                 ; return from subroutine

1221 : 3f91   clr $91             ; clear memory at address $91
1223   3f92   clr $92             ; clear memory at address $92
1225   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      eine User-Bytevariable auf den Stack pushen
;
;      input : x = Nummer der Bytevariablen (0..23), $a1..$b8
;      output: -
;      used  : a,x,$54,$91-$9e
;
;      called from $1623,$17ab
; ---------------------------------------------------------------------------

1226 : bf54   stx $54             ; store index register at address $54
1228   cd1187 jsr $1187           ; jump to subroutine at address $1187
122b   be54   ldx $54             ; load index reg. with value at addr. $54
122d   eea1   ldx $a1,x           ; load index reg. with value at $a1 + x
122f   bf92   stx $92             ; store index register at address $92
1231   5f     clrx                ; clear index register
1232   bf91   stx $91             ; store index register at address $91
1234   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      eine User-Wordvariable auf den Stack pushen
;
;      input : x = Nummer der Wordvariablen (0..11), $a1..$b8
;      output: -
;      used  : a,x,$55,$91-$9e
;
;      called from $162c,$17b2
; ---------------------------------------------------------------------------

1235 : bf55   stx $55             ; store index register at address $55
1237   cd1187 jsr $1187           ; jump to subroutine at address $1187
123a   be55   ldx $55             ; load index reg. with value at addr. $55
123c   58     lslx                ; shift left index register
123d   e6a1   lda $a1,x           ; load accu with value at addr. $a1 + x-reg.
123f   b791   sta $91             ; store accumulator at address $91
1241   e6a2   lda $a2,x           ; load accu with value at addr. $a2 + x-reg.
1243   b792   sta $92             ; store accumulator at address $92
1245   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      ON oder OFF auf den Rechenstack pushen, je nach Wertigkeit von x
;      ist x <> 0, dann ON (-1) auf Stack, sonst OFF (0)
;
;      input : x = Byte
;      output: -
;      used  : a,x,$54,$91-$9e
;
;      jumped from $1728,$18f6,$1912,$19dc
; ---------------------------------------------------------------------------

1246 : bf54   stx $54             ; x nach $54
1248   cd1187 jsr $1187           ; Platz auf Stack schaffen
124b   3d54   tst $54             ; ist $54 gleich #0 ?
124d   2708   beq $1257           ; falls ja, #0 auf den Stack setzen
124f   aeff   ldx #$ff            ;
1251   9f     txa                 ; falls nein,
1252   b792   sta $92             ;   #-1 (#$ffff) auf den Stack
1254   bf91   stx $91             ;
1256   81     rts                 ; return from subroutine

1257 : 3f91   clr $91             ; #0 auf den Stack setzen
1259   3f92   clr $92             ;
125b   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Bytewert (als Word) auf den Rechenstack pushen
;
;      input : x = Byte
;      output: -
;      used  : a,$91-$9e
;
;      called from $1733,$184e,$18fd
; ---------------------------------------------------------------------------

125c : cd1187 jsr $1187           ; Platz auf Stack schaffen
125f   9f     txa                 ;
1260   b792   sta $92             ; lowbyte auf $92
1262   4f     clra                ;
1263   b791   sta $91             ; 0 als highbyte auf $91
1265   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Unexplored byte
; ---------------------------------------------------------------------------

1266 : d2     db $d2              ; %11010010

; ---------------------------------------------------------------------------
;      Wordwert auf den Rechenstack pushen
;
;      input : $d2 = highbyte, $d3 = lowbyte
;      output: -
;      used  : a,$91-$9e
;
;      called from $1481,$173d,$176c,$179d,$17f5,$185b,$187c,$1979,$19d3
; ---------------------------------------------------------------------------

1267 : cd1187 jsr $1187           ; Platz auf Stack schaffen
126a   b6d2   lda $d2             ;
126c   b791   sta $91             ; highbyte nach $91
126e   b6d3   lda $d3             ;
1270   b792   sta $92             ; lowbyte nach $92
1272   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      eine User-Bitvariable mit Top-Of-Stack laden
;
;      input : x = Nummer der Bitvariablen (0..191), $91:$92 = ON oder OFF
;      output: -
;      used  : a,x,$54,$55,$56,[$a1-$b8]
;
;      jumped from $17b9
; ---------------------------------------------------------------------------

1273 : 9f     txa                 ; transfer index register to accumulator
1274   44     lsra                ; logical shift right accumulator
1275   44     lsra                ; logical shift right accumulator
1276   44     lsra                ; logical shift right accumulator
1277   b755   sta $55             ; store accumulator at address $55
1279   9f     txa                 ; transfer index register to accumulator
127a   a407   and #$07            ; AND accu with value #$07
127c   b756   sta $56             ; store accumulator at address $56
127e   97     tax                 ; transfer accumulator to index register
127f   a601   lda #$01            ; load accumulator with value #$01
1281   5d     tstx                ; test index register for negative or zero
1282   2704   beq $1288           ; branch if equal (Z is set)
1284 : 48     lsla                ; shift left accumulator
1285   5a     decx                ; decrement index register
1286   26fc   bne $1284           ; branch if not equal (Z is clear)
1288 : b754   sta $54             ; store accumulator at address $54
128a   b691   lda $91             ; load accu with value at address $91
128c   ba92   ora $92             ; OR accu with value at address $92
128e   2709   beq $1299           ; branch if equal (Z is set)
1290   b654   lda $54             ; load accu with value at address $54
1292   be55   ldx $55             ; load index reg. with value at addr. $55
1294   eaa1   ora $a1,x           ; OR accu with value at addr. $a1 + x-reg.
1296   e7a1   sta $a1,x           ; store accumulator at address $a1 + x-reg.
1298   81     rts                 ; return from subroutine

1299 : b654   lda $54             ; load accu with value at address $54
129b   43     coma                ; inverse accumulator (one's complement)
129c   be55   ldx $55             ; load index reg. with value at addr. $55
129e   e4a1   and $a1,x           ; AND accu with value at address $a1 + x
12a0   e7a1   sta $a1,x           ; store accumulator at address $a1 + x-reg.
12a2   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      eine User-Bytevariable mit Top-Of-Stack laden
;
;      input : x = Nummer der Bytevariablen (0..23), $91:$92 = Word
;      output: -
;      used  : a,x,$54,[$a1-$b8]
;
;      called from $163b,$17c0
; ---------------------------------------------------------------------------

12a3 : bf54   stx $54             ; store index register at address $54
12a5   b692   lda $92             ; load accu with value at address $92
12a7   e7a1   sta $a1,x           ; store accumulator at address $a1 + x-reg.
12a9   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      eine User-Wordvariable mit Top-Of-Stack laden
;
;      input : x = Nummer der Wordvariablen (0..11), $91:$92 = Word
;      output: -
;      used  : a,x,$55,[$a1-$b8]
;
;      called from $164a,$17c7
; ---------------------------------------------------------------------------

12aa : bf55   stx $55             ; store index register at address $55
12ac   58     lslx                ; shift left index register
12ad   b691   lda $91             ; load accu with value at address $91
12af   e7a1   sta $a1,x           ; store accumulator at address $a1 + x-reg.
12b1   b692   lda $92             ; load accu with value at address $92
12b3   e7a2   sta $a2,x           ; store accumulator at address $a2 + x-reg.
12b5   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      BASIC Token 40 - NOT
;
;      input : $91:$92 = Word
;      output: $91:$92 = NOT Word
;      used  : a,$91-$92
;
;      called from $1e46
; ---------------------------------------------------------------------------

12b6 : b692   lda $92             ; load accu with value at address $92
12b8   a8ff   eor #$ff            ; XOR accumulator with value #$ff
12ba   b792   sta $92             ; store accumulator at address $92
12bc   b691   lda $91             ; load accu with value at address $91
12be   a8ff   eor #$ff            ; XOR accumulator with value #$ff
12c0   b791   sta $91             ; store accumulator at address $91
12c2   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      BASIC Token 41 - AND
;
;      input : $91:$92 = Word2, $93:$94 = Word1
;      output: $91:$92 = Word1 AND Word2
;      used  : a,$91-$9c
;
;      called from $12d2,$1e48
; ---------------------------------------------------------------------------

12c3 : b694   lda $94             ; load accu with value at address $94
12c5   b492   and $92             ; AND accu with value at address $92
12c7   b792   sta $92             ; store accumulator at address $92
12c9   b693   lda $93             ; load accu with value at address $93
12cb   b491   and $91             ; AND accu with value at address $91
12cd   b791   sta $91             ; store accumulator at address $91
12cf   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

; ---------------------------------------------------------------------------
;      BASIC Token 42 - NAND
;
;      input : $91:$92 = Word2, $93:$94 = Word1
;      output: $91:$92 = Word1 NAND Word2
;      used  : a,$91-$9c
;
;      called from $1e4a
; ---------------------------------------------------------------------------

12d2 : adef   bsr $12c3           ; branch to subroutine at address $12c3
12d4   20e0   bra $12b6           ; branch always to $12b6

; ---------------------------------------------------------------------------
;      BASIC Token 43 - OR
;
;      input : $91:$92 = Word2, $93:$94 = Word1
;      output: $91:$92 = Word1 OR Word2
;      used  : a,$91-$9c
;
;      called from $12e5,$1e4c
; ---------------------------------------------------------------------------

12d6 : b694   lda $94             ; load accu with value at address $94
12d8   ba92   ora $92             ; OR accu with value at address $92
12da   b792   sta $92             ; store accumulator at address $92
12dc   b693   lda $93             ; load accu with value at address $93
12de   ba91   ora $91             ; OR accu with value at address $91
12e0   b791   sta $91             ; store accumulator at address $91
12e2   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

; ---------------------------------------------------------------------------
;      BASIC Token 44 - NOR
;
;      input : $91:$92 = Word2, $93:$94 = Word1
;      output: $91:$92 = Word1 NOR Word2
;      used  : a,$91-$9c
;
;      called from $1e4e
; ---------------------------------------------------------------------------

12e5 : adef   bsr $12d6           ; branch to subroutine at address $12d6
12e7   20cd   bra $12b6           ; branch always to $12b6

; ---------------------------------------------------------------------------
;      BASIC Token 45 - XOR
;
;      input : $91:$92 = Word2, $93:$94 = Word1
;      output: $91:$92 = Word1 XOR Word2
;      used  : a,$91-$9c
;
;      called from $1e50
; ---------------------------------------------------------------------------

12e9 : b694   lda $94             ; load accu with value at address $94
12eb   b892   eor $92             ; XOR accu with value at address $92
12ed   b792   sta $92             ; store accumulator at address $92
12ef   b693   lda $93             ; load accu with value at address $93
12f1   b891   eor $91             ; XOR accu with value at address $91
12f3   b791   sta $91             ; store accumulator at address $91
12f5   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

; ---------------------------------------------------------------------------
;      BASIC Token 46 - SHL
;
;      input : $91:$92 = Word2, $93:$94 = Word1
;      output: $91:$92 = Word1 << Word2
;      used  : a,x,$91-$9c,$de-$df
;
;      called from $1e52
; ---------------------------------------------------------------------------

12f8 : b693   lda $93             ; load accu with value at address $93
12fa   b7de   sta $de             ; store accumulator at address $de
12fc   b694   lda $94             ; load accu with value at address $94
12fe   b7df   sta $df             ; store accumulator at address $df
1300   b692   lda $92             ; load accu with value at address $92
1302   2707   beq $130b           ; branch if equal (Z is set)
1304 : 38df   lsl $df             ; shift left at address $df
1306   39de   rol $de             ; rotate left through carry at address $de
1308   4a     deca                ; decrement accumulator
1309   26f9   bne $1304           ; branch if not equal (Z is clear)
130b : bede   ldx $de             ; load index reg. with value at addr. $de
130d   b6df   lda $df             ; load accu with value at address $df
130f   b792   sta $92             ; store accumulator at address $92
1311   bf91   stx $91             ; store index register at address $91
1313   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

; ---------------------------------------------------------------------------
;      BASIC Token 47 - SHR
;
;      input : $91:$92 = Word2, $93:$94 = Word1
;      output: $91:$92 = Word1 >> Word2
;      used  : a,x,$91-$9c,$de-$df
;
;      called from $1e54
; ---------------------------------------------------------------------------

1316 : b693   lda $93             ; load accu with value at address $93
1318   b7de   sta $de             ; store accumulator at address $de
131a   b694   lda $94             ; load accu with value at address $94
131c   b7df   sta $df             ; store accumulator at address $df
131e   b692   lda $92             ; load accu with value at address $92
1320   2707   beq $1329           ; branch if equal (Z is set)
1322 : 37de   asr $de             ; arithmetic shift right at address $de
1324   36df   ror $df             ; rotate right through carry at address $df
1326   4a     deca                ; decrement accumulator
1327   26f9   bne $1322           ; branch if not equal (Z is clear)
1329 : bede   ldx $de             ; load index reg. with value at addr. $de
132b   b6df   lda $df             ; load accu with value at address $df
132d   b792   sta $92             ; store accumulator at address $92
132f   bf91   stx $91             ; store index register at address $91
1331   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

; ---------------------------------------------------------------------------
;      BASIC Token 50 - internes BASIC-Kommando
;      (unary -) negate last word on stack
;
;      input : $91:$92 = Word
;      output: $91:$92 = -Word
;      used  : a,x,$91-$92
;
;      called from $1e5a
; ---------------------------------------------------------------------------

1334 : be91   ldx $91             ; load index reg. with value at addr. $91
1336   b692   lda $92             ; load accu with value at address $92
1338   53     comx                ; inverse index register (one's complement)
1339   40     nega                ; negate accumulator (two's complement)
133a   2501   blo $133d           ; branch if accu is lower (C is set)
133c   5c     incx                ; increment index register
133d : b792   sta $92             ; store accumulator at address $92
133f   bf91   stx $91             ; store index register at address $91
1341   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      BASIC Token 51 - internes BASIC-Kommando
;      (+) add last two words on stack & push result to stack
;
;      input : $91:$92 = Word2, $93:$94 = Word1
;      output: $91:$92 = Word1 + Word2
;      used  : a,$91-$9c
;
;      called from $1636,$1645,$1e5c
; ---------------------------------------------------------------------------

1342 : b694   lda $94             ; load accu with value at address $94
1344   bb92   add $92             ; add value at address $92 to accumulator
1346   b792   sta $92             ; store accumulator at address $92
1348   b693   lda $93             ; load accu with value at address $93
134a   b991   adc $91             ; add (with carry) value at address $91
134c   b791   sta $91             ; store accumulator at address $91
134e   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

; ---------------------------------------------------------------------------
;      BASIC Token 52 - internes BASIC-Kommando
;      (-) subtract last word on stack from last-but-one word
;
;      input : $91:$92 = Word2, $93:$94 = Word1
;      output: $91:$92 = Word1 - Word2
;      used  : a,$91-$9c
;
;      called from $1e5e
; ---------------------------------------------------------------------------

1351 : b694   lda $94             ; load accu with value at address $94
1353   b092   sub $92             ; subtract value at address $92 from accu
1355   b792   sta $92             ; store accumulator at address $92
1357   b693   lda $93             ; load accu with value at address $93
1359   b291   sbc $91             ; subtract (with carry) value at addr. $91
135b   b791   sta $91             ; store accumulator at address $91
135d   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

; ---------------------------------------------------------------------------
;      BASIC Token 53 - internes BASIC-Kommando
;      (*) multiply last two words on stack
;
;      input : $91:$92 = Word2, $93:$94 = Word1
;      output: $91:$92 = Word1 * Word2
;      used  : a,x,$54-$59,$91-$9c
;
;      called from $1e60
; ---------------------------------------------------------------------------

1360 : b691   lda $91             ; load accu with value at address $91
1362   b756   sta $56             ; store accumulator at address $56
1364   b692   lda $92             ; load accu with value at address $92
1366   b757   sta $57             ; store accumulator at address $57
1368   b693   lda $93             ; load accu with value at address $93
136a   b754   sta $54             ; store accumulator at address $54
136c   b694   lda $94             ; load accu with value at address $94
136e   b755   sta $55             ; store accumulator at address $55
1370   cd1b84 jsr $1b84           ; jump to subroutine at address $1b84
1373   be54   ldx $54             ; load index reg. with value at addr. $54
1375   b655   lda $55             ; load accu with value at address $55
1377   b792   sta $92             ; store accumulator at address $92
1379   bf91   stx $91             ; store index register at address $91
137b   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

; ---------------------------------------------------------------------------
;      BASIC Token 54 - internes BASIC-Kommando
;      (/) divide last-but-one word on stack by last word
;
;      input : $91:$92 = Word2, $93:$94 = Word1
;      output: $91:$92 = Word1 / Word2
;      used  : a,x,$54-$59,$91-$9c
;
;      called from $1e62
; ---------------------------------------------------------------------------

137e : b691   lda $91             ; load accu with value at address $91
1380   b756   sta $56             ; store accumulator at address $56
1382   b692   lda $92             ; load accu with value at address $92
1384   b757   sta $57             ; store accumulator at address $57
1386   b693   lda $93             ; load accu with value at address $93
1388   b754   sta $54             ; store accumulator at address $54
138a   b694   lda $94             ; load accu with value at address $94
138c   b755   sta $55             ; store accumulator at address $55
138e   cd1c37 jsr $1c37           ; jump to subroutine at address $1c37
1391   be54   ldx $54             ; load index reg. with value at addr. $54
1393   b655   lda $55             ; load accu with value at address $55
1395   b792   sta $92             ; store accumulator at address $92
1397   bf91   stx $91             ; store index register at address $91
1399   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

; ---------------------------------------------------------------------------
;      BASIC Token 55 - MOD
;
;      input : $91:$92 = Word2, $93:$94 = Word1
;      output: $91:$92 = Word1 MOD Word2
;      used  : a,x,$54-$59,$91-$9c
;
;      called from $1e64
; ---------------------------------------------------------------------------

139c : b691   lda $91             ; load accu with value at address $91
139e   b756   sta $56             ; store accumulator at address $56
13a0   b692   lda $92             ; load accu with value at address $92
13a2   b757   sta $57             ; store accumulator at address $57
13a4   b693   lda $93             ; load accu with value at address $93
13a6   b754   sta $54             ; store accumulator at address $54
13a8   b694   lda $94             ; load accu with value at address $94
13aa   b755   sta $55             ; store accumulator at address $55
13ac   cd1c5d jsr $1c5d           ; jump to subroutine at address $1c5d
13af   be54   ldx $54             ; load index reg. with value at addr. $54
13b1   b655   lda $55             ; load accu with value at address $55
13b3   b792   sta $92             ; store accumulator at address $92
13b5   bf91   stx $91             ; store index register at address $91
13b7   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

; ---------------------------------------------------------------------------
;      BASIC Token 56 - ABS
;
;      input : $91:$92 = Word
;      output: $91:$92 = ABS(Word)
;      used  : a,x,$91-$92
;
;      called from $1e66
; ---------------------------------------------------------------------------

13ba : 3d91   tst $91             ; test for negative or zero at address $91
13bc   2a0d   bpl $13cb           ; branch if plus (N bit is clear)
13be   be91   ldx $91             ; load index reg. with value at addr. $91
13c0   b692   lda $92             ; load accu with value at address $92
13c2   53     comx                ; inverse index register (one's complement)
13c3   40     nega                ; negate accumulator (two's complement)
13c4   2501   blo $13c7           ; branch if accu is lower (C is set)
13c6   5c     incx                ; increment index register
13c7 : b792   sta $92             ; store accumulator at address $92
13c9   bf91   stx $91             ; store index register at address $91
13cb : 81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      BASIC Token 66 - SGN
;
;      input : $91:$92 = Word
;      output: $91:$92 = SGN(Word)
;      used  : a,x,$91-$92
;
;      called from $1e7a
; ---------------------------------------------------------------------------

13cc : 3d91   tst $91             ; test for negative or zero at address $91
13ce   2a07   bpl $13d7           ; branch if plus (N bit is clear)
13d0   aeff   ldx #$ff            ; load index register with value #$ff
13d2   9f     txa                 ; transfer index register to accumulator
13d3   b792   sta $92             ; store accumulator at address $92
13d5   bf91   stx $91             ; store index register at address $91
13d7 : b691   lda $91             ; load accu with value at address $91
13d9   2b0c   bmi $13e7           ; branch if minus (N bit is set)
13db   2604   bne $13e1           ; branch if not equal (Z is clear)
13dd   b692   lda $92             ; load accu with value at address $92
13df   2706   beq $13e7           ; branch if equal (Z is set)
13e1 : 3f91   clr $91             ; clear memory at address $91
13e3   a601   lda #$01            ; load accumulator with value #$01
13e5   b792   sta $92             ; store accumulator at address $92
13e7 : 81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      BASIC Token 57 - SQR
;
;      input : $91:$92 = Word
;      output: $91:$92 = SQR(Word)
;      used  : a,x,$54-$59,$91-$92,$d9-$db
;
;      called from $1e68
; ---------------------------------------------------------------------------

13e8 : b691   lda $91             ; load accu with value at address $91
13ea   ba92   ora $92             ; OR accu with value at address $92
13ec   2753   beq $1441           ; branch if equal (Z is set)
13ee   3d91   tst $91             ; test for negative or zero at address $91
13f0   2a05   bpl $13f7           ; branch if plus (N bit is clear)
13f2   3f91   clr $91             ; clear memory at address $91
13f4   3f92   clr $92             ; clear memory at address $92
13f6   81     rts                 ; return from subroutine

13f7 : 3fd9   clr $d9             ; clear memory at address $d9
13f9   a601   lda #$01            ; load accumulator with value #$01
13fb   b7da   sta $da             ; store accumulator at address $da
13fd   3fdb   clr $db             ; clear memory at address $db
13ff   2032   bra $1433           ; branch always to $1433

1401 : b6d9   lda $d9             ; load accu with value at address $d9
1403   b756   sta $56             ; store accumulator at address $56
1405   b6da   lda $da             ; load accu with value at address $da
1407   b757   sta $57             ; store accumulator at address $57
1409   b691   lda $91             ; load accu with value at address $91
140b   b754   sta $54             ; store accumulator at address $54
140d   b692   lda $92             ; load accu with value at address $92
140f   b755   sta $55             ; store accumulator at address $55
1411   cd1c37 jsr $1c37           ; jump to subroutine at address $1c37
1414   b655   lda $55             ; load accu with value at address $55
1416   bbda   add $da             ; add value at address $da to accumulator
1418   b755   sta $55             ; store accumulator at address $55
141a   b654   lda $54             ; load accu with value at address $54
141c   b9d9   adc $d9             ; add (with carry) value at address $d9
141e   b754   sta $54             ; store accumulator at address $54
1420   3f56   clr $56             ; clear memory at address $56
1422   a602   lda #$02            ; load accumulator with value #$02
1424   b757   sta $57             ; store accumulator at address $57
1426   cd1c37 jsr $1c37           ; jump to subroutine at address $1c37
1429   be54   ldx $54             ; load index reg. with value at addr. $54
142b   b655   lda $55             ; load accu with value at address $55
142d   b7da   sta $da             ; store accumulator at address $da
142f   bfd9   stx $d9             ; store index register at address $d9
1431   3cdb   inc $db             ; increment at address $db
1433 : b6db   lda $db             ; load accu with value at address $db
1435   a10a   cmp #$0a            ; compare accumulator with value #$0a
1437   25c8   blo $1401           ; branch if accu is lower (C is set)
1439   b6d9   lda $d9             ; load accu with value at address $d9
143b   b791   sta $91             ; store accumulator at address $91
143d   b6da   lda $da             ; load accu with value at address $da
143f   b792   sta $92             ; store accumulator at address $92
1441 : 81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      BASIC Token 48 - RANDOMIZE
;      Top-of-Stack als Startwert fuer den Zufallszahlengenerator benutzen
;      (falls Word null ist, dann TIMER benutzen, falls dieser null ist, die
;      Zahl 1808 als Startwert benutzen)
;
;      input : $91:$92 = Startwert
;      output: [$9f:$a0 = RAND-Zahl]
;      used  : a,x,$9f-$a0
;
;      called from $1e56
; ---------------------------------------------------------------------------

1442 : b691   lda $91             ; load accu with value at address $91
1444   ba92   ora $92             ; OR accu with value at address $92
1446   2609   bne $1451           ; branch if not equal (Z is clear)
1448   cd1155 jsr $1155           ; jump to subroutine at address $1155
144b   b7a0   sta $a0             ; store accumulator at address $a0
144d   bf9f   stx $9f             ; store index register at address $9f
144f   2008   bra $1459           ; branch always to $1459

1451 : b691   lda $91             ; load accu with value at address $91
1453   b79f   sta $9f             ; store accumulator at address $9f
1455   b692   lda $92             ; load accu with value at address $92
1457   b7a0   sta $a0             ; store accumulator at address $a0
1459 : b69f   lda $9f             ; load accu with value at address $9f
145b   baa0   ora $a0             ; OR accu with value at address $a0
145d   2608   bne $1467           ; branch if not equal (Z is clear)
145f   ae07   ldx #$07            ; load index register with value #$07
1461   a610   lda #$10            ; load accumulator with value #$10
1463   b7a0   sta $a0             ; store accumulator at address $a0
1465   bf9f   stx $9f             ; store index register at address $9f
1467 : 81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      BASIC Token 49 - RAND
;      RAND-Zahl mit 251 multiplizieren und auf den Stack pushen
;
;      input : [$9f:$a0 = RAND-Zahl]
;      output: $91:$92 und $9f:$a0 = aktuelle RAND-Zahl
;      used  : a,x,$54-$59,$91-$9e,$d2-$d3,$dd-$df
;
;      called from $1e58
; ---------------------------------------------------------------------------

1468 : 3f56   clr $56             ; clear memory at address $56
146a   a6fb   lda #$fb            ; load accumulator with value #$fb
146c   b757   sta $57             ; store accumulator at address $57
146e   ae00   ldx #$00            ; load index register with value #$00
1470   bfde   stx $de             ; store index register at address $de
1472   ae9f   ldx #$9f            ; load index register with value #$9f
1474   bfdf   stx $df             ; store index register at address $df
1476   cd1bb0 jsr $1bb0           ; jump to subroutine at address $1bb0
1479   b69f   lda $9f             ; load accu with value at address $9f
147b   b7d2   sta $d2             ; store accumulator at address $d2
147d   b6a0   lda $a0             ; load accu with value at address $a0
147f   b7d3   sta $d3             ; store accumulator at address $d3
1481   cc1267 jmp $1267           ; unconditional jump to address $1267

; ---------------------------------------------------------------------------
;      BASIC Token 58 - MAX
;
;      input : $91:$92 = Word2, $93:$94 = Word1
;      output: $91:$92 = MAX (Word1, Word2)
;      used  : a,$54-$57,$91-$9c
;
;      called from $1e6a
; ---------------------------------------------------------------------------

1484 : b691   lda $91             ; load accu with value at address $91
1486   b756   sta $56             ; store accumulator at address $56
1488   b692   lda $92             ; load accu with value at address $92
148a   b757   sta $57             ; store accumulator at address $57
148c   b693   lda $93             ; load accu with value at address $93
148e   b754   sta $54             ; store accumulator at address $54
1490   b694   lda $94             ; load accu with value at address $94
1492   b755   sta $55             ; store accumulator at address $55
1494   cd1b6b jsr $1b6b           ; jump to subroutine at address $1b6b
1497   2308   bls $14a1           ; branch if lower or same (C or Z set)
1499   b693   lda $93             ; load accu with value at address $93
149b   b791   sta $91             ; store accumulator at address $91
149d   b694   lda $94             ; load accu with value at address $94
149f   b792   sta $92             ; store accumulator at address $92
14a1 : cc11b8 jmp $11b8           ; unconditional jump to address $11b8

; ---------------------------------------------------------------------------
;      BASIC Token 59 - MIN
;
;      input : $91:$92 = Word2, $93:$94 = Word1
;      output: $91:$92 = MIN (Word1, Word2)
;      used  : a,$54-$57,$91-$9c
;
;      called from $1e6c
; ---------------------------------------------------------------------------

14a4 : b691   lda $91             ; load accu with value at address $91
14a6   b756   sta $56             ; store accumulator at address $56
14a8   b692   lda $92             ; load accu with value at address $92
14aa   b757   sta $57             ; store accumulator at address $57
14ac   b693   lda $93             ; load accu with value at address $93
14ae   b754   sta $54             ; store accumulator at address $54
14b0   b694   lda $94             ; load accu with value at address $94
14b2   b755   sta $55             ; store accumulator at address $55
14b4   cd1b6b jsr $1b6b           ; jump to subroutine at address $1b6b
14b7   2a08   bpl $14c1           ; branch if plus (N bit is clear)
14b9   b693   lda $93             ; load accu with value at address $93
14bb   b791   sta $91             ; store accumulator at address $91
14bd   b694   lda $94             ; load accu with value at address $94
14bf   b792   sta $92             ; store accumulator at address $92
14c1 : cc11b8 jmp $11b8           ; unconditional jump to address $11b8

; ---------------------------------------------------------------------------
;      BASIC Token 60 - internes BASIC-Kommando
;      (>) test if last-but-one word on stack is bigger than last word
;
;      input : $91:$92 = Word2, $93:$94 = Word1
;      output: $91:$92 = -1 wenn Word1 > Word2, sonst 0
;      used  : a,x,$54-$57,$91-$9c
;
;      called from $1e6e
; ---------------------------------------------------------------------------

14c4 : b691   lda $91             ; load accu with value at address $91
14c6   b756   sta $56             ; store accumulator at address $56
14c8   b692   lda $92             ; load accu with value at address $92
14ca   b757   sta $57             ; store accumulator at address $57
14cc   b693   lda $93             ; load accu with value at address $93
14ce   b754   sta $54             ; store accumulator at address $54
14d0   b694   lda $94             ; load accu with value at address $94
14d2   b755   sta $55             ; store accumulator at address $55
14d4   cd1b6b jsr $1b6b           ; jump to subroutine at address $1b6b
14d7   230a   bls $14e3           ; branch if lower or same (C or Z set)
14d9   aeff   ldx #$ff            ; load index register with value #$ff
14db   9f     txa                 ; transfer index register to accumulator
14dc   b792   sta $92             ; store accumulator at address $92
14de   bf91   stx $91             ; store index register at address $91
14e0   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

14e3 : 3f91   clr $91             ; clear memory at address $91
14e5   3f92   clr $92             ; clear memory at address $92
14e7   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

; ---------------------------------------------------------------------------
;      BASIC Token 62 - internes BASIC-Kommando
;      (<) test if last-but-one word on stack is lower than last word
;
;      input : $91:$92 = Word2, $93:$94 = Word1
;      output: $91:$92 = -1 wenn Word1 < Word2, sonst 0
;      used  : a,x,$54-$57,$91-$9c
;
;      called from $1e72
; ---------------------------------------------------------------------------

14ea : b691   lda $91             ; load accu with value at address $91
14ec   b756   sta $56             ; store accumulator at address $56
14ee   b692   lda $92             ; load accu with value at address $92
14f0   b757   sta $57             ; store accumulator at address $57
14f2   b693   lda $93             ; load accu with value at address $93
14f4   b754   sta $54             ; store accumulator at address $54
14f6   b694   lda $94             ; load accu with value at address $94
14f8   b755   sta $55             ; store accumulator at address $55
14fa   cd1b6b jsr $1b6b           ; jump to subroutine at address $1b6b
14fd   2a0a   bpl $1509           ; branch if plus (N bit is clear)
14ff   aeff   ldx #$ff            ; load index register with value #$ff
1501   9f     txa                 ; transfer index register to accumulator
1502   b792   sta $92             ; store accumulator at address $92
1504   bf91   stx $91             ; store index register at address $91
1506   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

1509 : 3f91   clr $91             ; clear memory at address $91
150b   3f92   clr $92             ; clear memory at address $92
150d   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

; ---------------------------------------------------------------------------
;      BASIC Token 61 - internes BASIC-Kommando
;      (>=) test if last-but-one word on stack is bigger/equal last word
;
;      input : $91:$92 = Word2, $93:$94 = Word1
;      output: $91:$92 = -1 wenn Word1 >= Word2, sonst 0
;      used  : a,x,$54-$57,$91-$9c
;
;      called from $1e70
; ---------------------------------------------------------------------------

1510 : b691   lda $91             ; load accu with value at address $91
1512   b756   sta $56             ; store accumulator at address $56
1514   b692   lda $92             ; load accu with value at address $92
1516   b757   sta $57             ; store accumulator at address $57
1518   b693   lda $93             ; load accu with value at address $93
151a   b754   sta $54             ; store accumulator at address $54
151c   b694   lda $94             ; load accu with value at address $94
151e   b755   sta $55             ; store accumulator at address $55
1520   cd1b6b jsr $1b6b           ; jump to subroutine at address $1b6b
1523   2a07   bpl $152c           ; branch if plus (N bit is clear)
1525   3f91   clr $91             ; clear memory at address $91
1527   3f92   clr $92             ; clear memory at address $92
1529   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

152c : aeff   ldx #$ff            ; load index register with value #$ff
152e   9f     txa                 ; transfer index register to accumulator
152f   b792   sta $92             ; store accumulator at address $92
1531   bf91   stx $91             ; store index register at address $91
1533   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

; ---------------------------------------------------------------------------
;      BASIC Token 63 - internes BASIC-Kommando
;      (<=) test if last-but-one word on stack is lower/equal to last word
;
;      input : $91:$92 = Word2, $93:$94 = Word1
;      output: $91:$92 = -1 wenn Word1 <= Word2, sonst 0
;      used  : a,x,$54-$57,$91-$9c
;
;      called from $1e74
; ---------------------------------------------------------------------------

1536 : b691   lda $91             ; load accu with value at address $91
1538   b756   sta $56             ; store accumulator at address $56
153a   b692   lda $92             ; load accu with value at address $92
153c   b757   sta $57             ; store accumulator at address $57
153e   b693   lda $93             ; load accu with value at address $93
1540   b754   sta $54             ; store accumulator at address $54
1542   b694   lda $94             ; load accu with value at address $94
1544   b755   sta $55             ; store accumulator at address $55
1546   cd1b6b jsr $1b6b           ; jump to subroutine at address $1b6b
1549   2307   bls $1552           ; branch if lower or same (unsigned)
154b   3f91   clr $91             ; clear memory at address $91
154d   3f92   clr $92             ; clear memory at address $92
154f   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

1552 : aeff   ldx #$ff            ; load index register with value #$ff
1554   9f     txa                 ; transfer index register to accumulator
1555   b792   sta $92             ; store accumulator at address $92
1557   bf91   stx $91             ; store index register at address $91
1559   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

; ---------------------------------------------------------------------------
;      BASIC Token 64 - internes BASIC-Kommando
;      (=) test if last two words on stack are equal
;
;      input : $91:$92 = Word2, $93:$94 = Word1
;      output: $91:$92 = -1 wenn Word1 = Word2, sonst 0
;      used  : a,x,$91-$9c
;
;      called from $1e76
; ---------------------------------------------------------------------------

155c : b693   lda $93             ; load accu with value at address $93
155e   b191   cmp $91             ; compare accu with value at address $91
1560   2610   bne $1572           ; branch if not equal (Z is clear)
1562   b694   lda $94             ; load accu with value at address $94
1564   b192   cmp $92             ; compare accu with value at address $92
1566   260a   bne $1572           ; branch if not equal (Z is clear)
1568   aeff   ldx #$ff            ; load index register with value #$ff
156a   9f     txa                 ; transfer index register to accumulator
156b   b792   sta $92             ; store accumulator at address $92
156d   bf91   stx $91             ; store index register at address $91
156f   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

1572 : 3f91   clr $91             ; clear memory at address $91
1574   3f92   clr $92             ; clear memory at address $92
1576   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

; ---------------------------------------------------------------------------
;      BASIC Token 65 - internes BASIC-Kommando
;      (<>) test if last two words on stack are not equal
;
;      input : $91:$92 = Word2, $93:$94 = Word1
;      output: $91:$92 = -1 wenn Word1 <> Word2, sonst 0
;      used  : a,x,$91-$9c
;
;      called from $1e78
; ---------------------------------------------------------------------------

1579 : b693   lda $93             ; load accu with value at address $93
157b   b191   cmp $91             ; compare accu with value at address $91
157d   260d   bne $158c           ; branch if not equal (Z is clear)
157f   b694   lda $94             ; load accu with value at address $94
1581   b192   cmp $92             ; compare accu with value at address $92
1583   2607   bne $158c           ; branch if not equal (Z is clear)
1585   3f91   clr $91             ; clear memory at address $91
1587   3f92   clr $92             ; clear memory at address $92
1589   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

158c : aeff   ldx #$ff            ; load index register with value #$ff
158e   9f     txa                 ; transfer index register to accumulator
158f   b792   sta $92             ; store accumulator at address $92
1591   bf91   stx $91             ; store index register at address $91
1593   cc11b8 jmp $11b8           ; unconditional jump to address $11b8

; ---------------------------------------------------------------------------
;      nach Reset den fuer den SYS-Befehl, fuer den GOSUB-Stack und fuer
;      die BASIC-IRQ-Routine reservierten Arbeitsspeicher initialisieren
;
;      input : -
;      output: -
;      used  : a,$b9-$c7
;
;      called from $0963
; ---------------------------------------------------------------------------

1596 : a6cc   lda #$cc            ; load accumulator with value #$cc
1598   b7bd   sta $bd             ; store accumulator at address $bd
159a   3fbe   clr $be             ; clear memory at address $be
159c   3fbf   clr $bf             ; clear memory at address $bf
159e   3fc0   clr $c0             ; clear memory at address $c0
15a0   3fc1   clr $c1             ; clear memory at address $c1
15a2   3fc2   clr $c2             ; clear memory at address $c2
15a4   3fc3   clr $c3             ; clear memory at address $c3
15a6   3fc4   clr $c4             ; clear memory at address $c4
15a8   3fc5   clr $c5             ; clear memory at address $c5
15aa   3fc6   clr $c6             ; clear memory at address $c6
15ac   3fc7   clr $c7             ; clear memory at address $c7
15ae   3fb9   clr $b9             ; clear memory at address $b9
15b0   3fba   clr $ba             ; clear memory at address $ba
15b2   3fbb   clr $bb             ; clear memory at address $bb
15b4   3fbc   clr $bc             ; clear memory at address $bc
15b6   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      BASIC Token 0, 18, 19, 38, 39, 67, 68, 69, 78, 79 - werden ignoriert
;      called from $1df6,$1e1a,$1e1c,$1e42,$1e44,$1e7c,$1e7e,$1e80,$1e92,
;                  $1e94
; ---------------------------------------------------------------------------

15b7 : 81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      BASIC Token 1 - internes BASIC-Kommando
;      Aufruf der Prozedur zum Loeschen des Rechenstacks
;      called from $1df8
; ---------------------------------------------------------------------------

15b8 : cc116a jmp $116a           ; unconditional jump to address $116a

; ---------------------------------------------------------------------------
;      BASIC Token 2 - PAUSE
;      Programmausfuehrung fuer bestimmte Anzahl Millisekunden unterbrechen,
;      dabei RUN-LED loeschen
;
;      input : $91:$92 = Anzahl der 20 ms Einheiten
;      output: -
;      used  : a,$0(%00000100),$8e-$8f,$ce-$cf
;
;      called from $1dfa
; ---------------------------------------------------------------------------

15bb : 1400   bset #2,$00         ; set bit #2 at memory address $00
15bd   b691   lda $91             ; load accu with value at address $91
15bf   b7ce   sta $ce             ; store accumulator at address $ce
15c1   b692   lda $92             ; load accu with value at address $92
15c3   b7cf   sta $cf             ; store accumulator at address $cf
15c5   cd10f7 jsr $10f7           ; jump to subroutine at address $10f7
15c8   1500   bclr #2,$00         ; clear bit #2 at memory address $00
15ca   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      BASIC Token 3 w - GOTO (und ELSE)
;      nachfolgendes Word aus EEPROM holen und BASIC-PC gleich Word setzen
;      called from $163e,$164d,$1dfc
; ---------------------------------------------------------------------------

15cb : cd0e0d jsr $0e0d           ; jump to subroutine at address $0e0d
15ce   b7d0   sta $d0             ; store accumulator at address $d0
15d0   bfcf   stx $cf             ; store index register at address $cf
15d2   cd0e01 jsr $0e01           ; jump to subroutine at address $0e01
15d5   b6cf   lda $cf             ; load accu with value at address $cf
15d7   b7d3   sta $d3             ; store accumulator at address $d3
15d9   b6d0   lda $d0             ; load accu with value at address $d0
15db   b7d4   sta $d4             ; store accumulator at address $d4
15dd   cc0de5 jmp $0de5           ; unconditional jump to address $0de5

; ---------------------------------------------------------------------------
;      BASIC Token 4 w - IF .. THEN
;      nachfolgendes Word aus EEPROM holen und BASIC-PC gleich Word setzen,
;      falls das vom Rechenstack geholte letzte Word gleich 0 ist
;      called from $1dfe
; ---------------------------------------------------------------------------

15e0 : cd0e0d jsr $0e0d           ; jump to subroutine at address $0e0d
15e3   b7cf   sta $cf             ; store accumulator at address $cf
15e5   bfce   stx $ce             ; store index register at address $ce
15e7   b691   lda $91             ; load accu with value at address $91
15e9   ba92   ora $92             ; OR accu with value at address $92
15eb   260e   bne $15fb           ; branch if not equal (Z is clear)
15ed   cd0e01 jsr $0e01           ; jump to subroutine at address $0e01
15f0   b6ce   lda $ce             ; load accu with value at address $ce
15f2   b7d3   sta $d3             ; store accumulator at address $d3
15f4   b6cf   lda $cf             ; load accu with value at address $cf
15f6   b7d4   sta $d4             ; store accumulator at address $d4
15f8   cd0de5 jsr $0de5           ; jump to subroutine at address $0de5
15fb : 81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      gemeinsamer Codeteile fuer Token 74 und 75
; ---------------------------------------------------------------------------

15fc : cd0e0d jsr $0e0d           ; jump to subroutine at address $0e0d
15ff   b7cf   sta $cf             ; store accumulator at address $cf
1601   bfce   stx $ce             ; store index register at address $ce
1603   b691   lda $91             ; load accu with value at address $91
1605   b193   cmp $93             ; compare accu with value at address $93
1607   2615   bne $161e           ; branch if not equal (Z is clear)
1609   b692   lda $92             ; load accu with value at address $92
160b   b194   cmp $94             ; compare accu with value at address $94
160d   260e   bne $161d           ; branch if not equal (Z is clear)
160f   cd0e01 jsr $0e01           ; jump to subroutine at address $0e01
1612   b6ce   lda $ce             ; load accu with value at address $ce
1614   b7d3   sta $d3             ; store accumulator at address $d3
1616   b6cf   lda $cf             ; load accu with value at address $cf
1618   b7d4   sta $d4             ; store accumulator at address $d4
161a   cd0de5 jsr $0de5           ; jump to subroutine at address $0de5
161d : 81     rts                 ; return from subroutine

161e : 81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      BASIC Token 74 b w - internes BASIC-Kommando
;      fuer FOR..NEXT-Schleifen: Vergleiche Word auf dem Stack mit
;      der Bytevariablen Nummer b, falls beide gleich sind springe
;      zur EEPROM-Adresse w
;      called from $1e8a
; ---------------------------------------------------------------------------

161f : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
1622   97     tax                 ; transfer accumulator to index register
1623   cd1226 jsr $1226           ; jump to subroutine at address $1226
1626   20d4   bra $15fc           ; branch always to $15fc

; ---------------------------------------------------------------------------
;      BASIC Token 75 b w - internes BASIC-Kommando
;      fuer FOR..NEXT-Schleifen: Vergleiche Word auf dem Stack mit
;      der Wordvariablen Nummer b, falls beide gleich sind springe
;      zur EEPROM-Adresse w
;      called from $1e8c
; ---------------------------------------------------------------------------

1628 : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
162b   97     tax                 ; transfer accumulator to index register
162c   cd1235 jsr $1235           ; jump to subroutine at address $1235
162f   20cb   bra $15fc           ; branch always to $15fc

; ---------------------------------------------------------------------------
;      BASIC Token 76 b w - internes BASIC-Kommando
;      fuer FOR..NEXT-Schleifen: Addiere zur Bytevariablen Nummer b das
;      letzte Word auf dem Stack und springe zur EEPROM-Adresse w
;      called from $1e8e
; ---------------------------------------------------------------------------

1631 : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
1634   b7ce   sta $ce             ; store accumulator at address $ce
1636   cd1342 jsr $1342           ; jump to subroutine at address $1342
1639   bece   ldx $ce             ; load index reg. with value at addr. $ce
163b   cd12a3 jsr $12a3           ; jump to subroutine at address $12a3
163e   208b   bra $15cb           ; branch always to $15cb

; ---------------------------------------------------------------------------
;      BASIC Token 77 b w - internes BASIC-Kommando
;      fuer FOR..NEXT-Schleifen: Addiere zur Wordvariablen Nummer b das
;      letzte Word auf dem Stack und springe zur EEPROM-Adresse w
;      called from $1e90
; ---------------------------------------------------------------------------

1640 : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
1643   b7ce   sta $ce             ; store accumulator at address $ce
1645   cd1342 jsr $1342           ; jump to subroutine at address $1342
1648   bece   ldx $ce             ; load index reg. with value at addr. $ce
164a   cd12aa jsr $12aa           ; jump to subroutine at address $12aa
164d   cc15cb jmp $15cb           ; unconditional jump to address $15cb

; ---------------------------------------------------------------------------
;      Unexplored byte
; ---------------------------------------------------------------------------

1650 : ce     db $ce              ; %11001110

; ---------------------------------------------------------------------------
;      Code fuer GOSUB
; ---------------------------------------------------------------------------

1651 : b6c0   lda $c0             ; load accu with value at address $c0
1653   bac1   ora $c1             ; OR accu with value at address $c1
1655   260a   bne $1661           ; branch if not equal (Z is clear)
1657   b666   lda $66             ; load accu with value at address $66
1659   b7c0   sta $c0             ; store accumulator at address $c0
165b   b667   lda $67             ; load accu with value at address $67
165d   b7c1   sta $c1             ; store accumulator at address $c1
165f   202e   bra $168f           ; branch always to $168f

1661 : b6c2   lda $c2             ; load accu with value at address $c2
1663   bac3   ora $c3             ; OR accu with value at address $c3
1665   260a   bne $1671           ; branch if not equal (Z is clear)
1667   b666   lda $66             ; load accu with value at address $66
1669   b7c2   sta $c2             ; store accumulator at address $c2
166b   b667   lda $67             ; load accu with value at address $67
166d   b7c3   sta $c3             ; store accumulator at address $c3
166f   201e   bra $168f           ; branch always to $168f

1671 : b6c4   lda $c4             ; load accu with value at address $c4
1673   bac5   ora $c5             ; OR accu with value at address $c5
1675   260a   bne $1681           ; branch if not equal (Z is clear)
1677   b666   lda $66             ; load accu with value at address $66
1679   b7c4   sta $c4             ; store accumulator at address $c4
167b   b667   lda $67             ; load accu with value at address $67
167d   b7c5   sta $c5             ; store accumulator at address $c5
167f   200e   bra $168f           ; branch always to $168f

1681 : b6c6   lda $c6             ; load accu with value at address $c6
1683   bac7   ora $c7             ; OR accu with value at address $c7
1685   2608   bne $168f           ; branch if not equal (Z is clear)
1687   b666   lda $66             ; load accu with value at address $66
1689   b7c6   sta $c6             ; store accumulator at address $c6
168b   b667   lda $67             ; load accu with value at address $67
168d   b7c7   sta $c7             ; store accumulator at address $c7
168f : cd0e01 jsr $0e01           ; jump to subroutine at address $0e01
1692   b6ce   lda $ce             ; load accu with value at address $ce
1694   b7d3   sta $d3             ; store accumulator at address $d3
1696   b6cf   lda $cf             ; load accu with value at address $cf
1698   b7d4   sta $d4             ; store accumulator at address $d4
169a   cc0de5 jmp $0de5           ; unconditional jump to address $0de5

; ---------------------------------------------------------------------------
;      BASIC Token 5 w - GOSUB
;      Subroutine aufrufen, falls auf dem GOSUB-Stack (hat eine Groesse von
;      4 Eintraegen) noch Platz fuer den aktuellen BASIC-PC ist
;      called from $1e00
; ---------------------------------------------------------------------------

169d : cd0e0d jsr $0e0d           ; jump to subroutine at address $0e0d
16a0   b7cf   sta $cf             ; store accumulator at address $cf
16a2   bfce   stx $ce             ; store index register at address $ce
16a4   20ab   bra $1651           ; branch always to $1651

; ---------------------------------------------------------------------------
;      BASIC Token 6 - RETURN
;      nach der Ausfuehrung einer Subroutine den BASIC-PC restaurieren
;      called from $1e02
; ---------------------------------------------------------------------------

16a6 : b6c6   lda $c6             ; load accu with value at address $c6
16a8   bac7   ora $c7             ; OR accu with value at address $c7
16aa   2713   beq $16bf           ; branch if equal (Z is set)
16ac   cd0e01 jsr $0e01           ; jump to subroutine at address $0e01
16af   b6c6   lda $c6             ; load accu with value at address $c6
16b1   b7d3   sta $d3             ; store accumulator at address $d3
16b3   b6c7   lda $c7             ; load accu with value at address $c7
16b5   b7d4   sta $d4             ; store accumulator at address $d4
16b7   cd0de5 jsr $0de5           ; jump to subroutine at address $0de5
16ba   3fc6   clr $c6             ; clear memory at address $c6
16bc   3fc7   clr $c7             ; clear memory at address $c7
16be   81     rts                 ; return from subroutine

16bf : b6c4   lda $c4             ; load accu with value at address $c4
16c1   bac5   ora $c5             ; OR accu with value at address $c5
16c3   2713   beq $16d8           ; branch if equal (Z is set)
16c5   cd0e01 jsr $0e01           ; jump to subroutine at address $0e01
16c8   b6c4   lda $c4             ; load accu with value at address $c4
16ca   b7d3   sta $d3             ; store accumulator at address $d3
16cc   b6c5   lda $c5             ; load accu with value at address $c5
16ce   b7d4   sta $d4             ; store accumulator at address $d4
16d0   cd0de5 jsr $0de5           ; jump to subroutine at address $0de5
16d3   3fc4   clr $c4             ; clear memory at address $c4
16d5   3fc5   clr $c5             ; clear memory at address $c5
16d7   81     rts                 ; return from subroutine

16d8 : b6c2   lda $c2             ; load accu with value at address $c2
16da   bac3   ora $c3             ; OR accu with value at address $c3
16dc   2713   beq $16f1           ; branch if equal (Z is set)
16de   cd0e01 jsr $0e01           ; jump to subroutine at address $0e01
16e1   b6c2   lda $c2             ; load accu with value at address $c2
16e3   b7d3   sta $d3             ; store accumulator at address $d3
16e5   b6c3   lda $c3             ; load accu with value at address $c3
16e7   b7d4   sta $d4             ; store accumulator at address $d4
16e9   cd0de5 jsr $0de5           ; jump to subroutine at address $0de5
16ec   3fc2   clr $c2             ; clear memory at address $c2
16ee   3fc3   clr $c3             ; clear memory at address $c3
16f0   81     rts                 ; return from subroutine

16f1 : b6c0   lda $c0             ; load accu with value at address $c0
16f3   bac1   ora $c1             ; OR accu with value at address $c1
16f5   2712   beq $1709           ; branch if equal (Z is set)
16f7   cd0e01 jsr $0e01           ; jump to subroutine at address $0e01
16fa   b6c0   lda $c0             ; load accu with value at address $c0
16fc   b7d3   sta $d3             ; store accumulator at address $d3
16fe   b6c1   lda $c1             ; load accu with value at address $c1
1700   b7d4   sta $d4             ; store accumulator at address $d4
1702   cd0de5 jsr $0de5           ; jump to subroutine at address $0de5
1705   3fc0   clr $c0             ; clear memory at address $c0
1707   3fc1   clr $c1             ; clear memory at address $c1
1709 : 81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      BASIC Token 8 w - SYS
;      Assembler-Subroutine mittels eines kleinen Maschinenspracheprogramms
;      im RAM (von Adresse $bd bis $bf) aufrufen
;      called from $1e06
; ---------------------------------------------------------------------------

170a : cd0e0d jsr $0e0d           ; jump to subroutine at address $0e0d
170d   b7bf   sta $bf             ; store accumulator at address $bf
170f   bfbe   stx $be             ; store index register at address $be
1711   bdbd   jsr $bd             ; jump to subroutine at address $bd
1713   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      BASIC Token 9 b - SLOWMODE
;      called from $1e08
; ---------------------------------------------------------------------------

1714 : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
1717   4d     tsta                ; test accumulator for negative or zero
1718   2703   beq $171d           ; branch if equal (Z is set)
171a   cc110b jmp $110b           ; unconditional jump to address $110b

171d : cc1112 jmp $1112           ; unconditional jump to address $1112

; ---------------------------------------------------------------------------
;      BASIC Token 10 b - internes BASIC-Kommando
;      push data from bitport number b to stack
;      called from $1e0a
; ---------------------------------------------------------------------------

1720 : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
1723   97     tax                 ; transfer accumulator to index register
1724   cd098b jsr $098b           ; jump to subroutine at address $098b
1727   97     tax                 ; transfer accumulator to index register
1728   cc1246 jmp $1246           ; unconditional jump to address $1246

; ---------------------------------------------------------------------------
;      BASIC Token 11 b - internes BASIC-Kommando
;      push data from byteport number b to stack
;      called from $1e0c
; ---------------------------------------------------------------------------

172b : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
172e   97     tax                 ; transfer accumulator to index register
172f   cd09ab jsr $09ab           ; jump to subroutine at address $09ab
1732   97     tax                 ; transfer accumulator to index register
1733   cc125c jmp $125c           ; unconditional jump to address $125c

; ---------------------------------------------------------------------------
;      BASIC Token 12 - internes BASIC-Kommando
;      push data from wordport to stack
;
;      input : [$1:$2 = PORTB/PORTC]
;      output: $91:$92 = PORTB/PORTC
;      used  : a,x,$91-$9e,$d2-$d3
;
;      called from $1e0e
; ---------------------------------------------------------------------------

1736 : cd09b0 jsr $09b0           ; jump to subroutine at address $09b0
1739   b7d3   sta $d3             ; store accumulator at address $d3
173b   bfd2   stx $d2             ; store index register at address $d2
173d   cc1267 jmp $1267           ; unconditional jump to address $1267

; ---------------------------------------------------------------------------
;      BASIC Token 13 b - internes BASIC-Kommando
;      store Top-Of-Stack to bitport number b
;      called from $1e10
; ---------------------------------------------------------------------------

1740 : b692   lda $92             ; load accu with value at address $92
1742   b7ce   sta $ce             ; store accumulator at address $ce
1744   cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
1747   97     tax                 ; transfer accumulator to index register
1748   cc09b6 jmp $09b6           ; unconditional jump to address $09b6

; ---------------------------------------------------------------------------
;      BASIC Token 14 b - internes BASIC-Kommando
;      store Top-Of-Stack to byteport number b
;      called from $1e12
; ---------------------------------------------------------------------------

174b : b692   lda $92             ; load accu with value at address $92
174d   b7ce   sta $ce             ; store accumulator at address $ce
174f   cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
1752   97     tax                 ; transfer accumulator to index register
1753   cc09ea jmp $09ea           ; unconditional jump to address $09ea

; ---------------------------------------------------------------------------
;      BASIC Token 15 - internes BASIC-Kommando
;      store Top-Of-Stack to wordport
;
;      input : $91:$92 = PORTB/PORTC
;      output: [$1:$2 = PORTB/PORTC]
;      used  : a,x,$1-$2,$5-$6,$ce-$cf
;
;      called from $1e14
; ---------------------------------------------------------------------------

1756 : b691   lda $91             ; load accu with value at address $91
1758   b7ce   sta $ce             ; store accumulator at address $ce
175a   b692   lda $92             ; load accu with value at address $92
175c   b7cf   sta $cf             ; store accumulator at address $cf
175e   cc09f8 jmp $09f8           ; unconditional jump to address $09f8

; ---------------------------------------------------------------------------
;      BASIC Token 16 b - internes BASIC-Kommando
;      push data from ad-port number b to stack
;      called from $1e16
; ---------------------------------------------------------------------------

1761 : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
1764   97     tax                 ; transfer accumulator to index register
1765   cd0a87 jsr $0a87           ; jump to subroutine at address $0a87
1768   b7d3   sta $d3             ; store accumulator at address $d3
176a   bfd2   stx $d2             ; store index register at address $d2
176c   cc1267 jmp $1267           ; unconditional jump to address $1267

; ---------------------------------------------------------------------------
;      BASIC Token 17 b - internes BASIC-Kommando
;      store Top-Of-Stack to da-port number b
;      called from $1e18
; ---------------------------------------------------------------------------

176f : b692   lda $92             ; load accu with value at address $92
1771   b7ce   sta $ce             ; store accumulator at address $ce
1773   cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
1776   97     tax                 ; transfer accumulator to index register
1777   cc0a9d jmp $0a9d           ; unconditional jump to address $0a9d

; ---------------------------------------------------------------------------
;      BASIC Token 80 b - TOG
;      called from $1e96
; ---------------------------------------------------------------------------

177a : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
177d   97     tax                 ; transfer accumulator to index register
177e   cc0a0a jmp $0a0a           ; unconditional jump to address $0a0a

; ---------------------------------------------------------------------------
;      BASIC Token 81 b - PULSE
;      called from $1e98
; ---------------------------------------------------------------------------

1781 : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
1784   97     tax                 ; transfer accumulator to index register
1785   cc0a28 jmp $0a28           ; unconditional jump to address $0a28

; ---------------------------------------------------------------------------
;      BASIC Token 82 b - DEACT
;      Bitport Nummer b deaktivieren
;      called from $1e9a
; ---------------------------------------------------------------------------

1788 : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
178b   97     tax                 ; transfer accumulator to index register
178c   cc0a5c jmp $0a5c           ; unconditional jump to address $0a5c

; ---------------------------------------------------------------------------
;      BASIC Token 83 b - DEACT
;      Byteport Nummer b deaktivieren
;      called from $1e9c
; ---------------------------------------------------------------------------

178f : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
1792   97     tax                 ; transfer accumulator to index register
1793   cc0a7d jmp $0a7d           ; unconditional jump to address $0a7d

; ---------------------------------------------------------------------------
;      BASIC Token 20 w - internes BASIC-Kommando
;      push wordvalue w to stack
;      called from $1e1e
; ---------------------------------------------------------------------------

1796 : cd0e0d jsr $0e0d           ; jump to subroutine at address $0e0d
1799   b7d3   sta $d3             ; store accumulator at address $d3
179b   bfd2   stx $d2             ; store index register at address $d2
179d   cc1267 jmp $1267           ; unconditional jump to address $1267

; ---------------------------------------------------------------------------
;      BASIC Token 21 b - internes BASIC-Kommando
;      push bitvariable number b to stack
;      called from $1e20
; ---------------------------------------------------------------------------

17a0 : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
17a3   97     tax                 ; transfer accumulator to index register
17a4   cc11f3 jmp $11f3           ; unconditional jump to address $11f3

; ---------------------------------------------------------------------------
;      BASIC Token 22 b - internes BASIC-Kommando
;      push bytevariable number b to stack
;      called from $1e22
; ---------------------------------------------------------------------------

17a7 : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
17aa   97     tax                 ; transfer accumulator to index register
17ab   cc1226 jmp $1226           ; unconditional jump to address $1226

; ---------------------------------------------------------------------------
;      BASIC Token 23 b - internes BASIC-Kommando
;      push wordvariable number b to stack
;      called from $1e24
; ---------------------------------------------------------------------------

17ae : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
17b1   97     tax                 ; transfer accumulator to index register
17b2   cc1235 jmp $1235           ; unconditional jump to address $1235

; ---------------------------------------------------------------------------
;      BASIC Token 24 b - internes BASIC-Kommando
;      store Top-Of-Stack to bitvariable number b
;      called from $1e26
; ---------------------------------------------------------------------------

17b5 : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
17b8   97     tax                 ; transfer accumulator to index register
17b9   cc1273 jmp $1273           ; unconditional jump to address $1273

; ---------------------------------------------------------------------------
;      BASIC Token 25 b - internes BASIC-Kommando
;      store Top-Of-Stack to bytevariable number b
;      called from $1e28
; ---------------------------------------------------------------------------

17bc : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
17bf   97     tax                 ; transfer accumulator to index register
17c0   cc12a3 jmp $12a3           ; unconditional jump to address $12a3

; ---------------------------------------------------------------------------
;      BASIC Token 26 b - internes BASIC-Kommando
;      store Top-Of-Stack to wordvariable number b
;      called from $1e2a
; ---------------------------------------------------------------------------

17c3 : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
17c6   97     tax                 ; transfer accumulator to index register
17c7   cc12aa jmp $12aa           ; unconditional jump to address $12aa

; ---------------------------------------------------------------------------
;      BASIC Token 27 w - LOOKTAB
;      push word number Top-Of-Stack of table at address w to stack
;
;      Diese Routine kann in eigenen Assemblerprogrammen verwendet werden,
;      wenn diese ueber die Adresse $17cd (statt ueber die "richtige" Start-
;      adresse $17ca) aufgerufen wird. Wer auf dem Stack eine Nummer
;      und sowohl im Akku als auch im Index Register den Wert null ueber-
;      gibt, kann jedes beliebige Word aus dem EEPROM lesen.
;
;      called from $1e2c
; ---------------------------------------------------------------------------

17ca : cd0e0d jsr $0e0d           ; jump to subroutine at address $0e0d
17cd   b7d1   sta $d1             ; store accumulator at address $d1
17cf   bfd0   stx $d0             ; store index register at address $d0
17d1   b666   lda $66             ; load accu with value at address $66
17d3   b7ce   sta $ce             ; store accumulator at address $ce
17d5   b667   lda $67             ; load accu with value at address $67
17d7   b7cf   sta $cf             ; store accumulator at address $cf
17d9   cd0e01 jsr $0e01           ; jump to subroutine at address $0e01
17dc   be91   ldx $91             ; load index reg. with value at addr. $91
17de   b692   lda $92             ; load accu with value at address $92
17e0   48     lsla                ; shift left accumulator
17e1   59     rolx                ; rotate index register left through carry
17e2   bbd1   add $d1             ; add value at address $d1 to accumulator
17e4   b7d4   sta $d4             ; store accumulator at address $d4
17e6   9f     txa                 ; transfer index register to accumulator
17e7   b9d0   adc $d0             ; add (with carry) value at address $d0
17e9   b7d3   sta $d3             ; store accumulator at address $d3
17eb   cd0de5 jsr $0de5           ; jump to subroutine at address $0de5
17ee   cd0e0d jsr $0e0d           ; jump to subroutine at address $0e0d
17f1   b7d3   sta $d3             ; store accumulator at address $d3
17f3   bfd2   stx $d2             ; store index register at address $d2
17f5   cd1267 jsr $1267           ; jump to subroutine at address $1267
17f8   cd0e01 jsr $0e01           ; jump to subroutine at address $0e01
17fb   b6ce   lda $ce             ; load accu with value at address $ce
17fd   b7d3   sta $d3             ; store accumulator at address $d3
17ff   b6cf   lda $cf             ; load accu with value at address $cf
1801   b7d4   sta $d4             ; store accumulator at address $d4
1803   cc0de5 jmp $0de5           ; unconditional jump to address $0de5

; ---------------------------------------------------------------------------
;      BASIC Token 28 b - internes BASIC-Kommando
;      push internal variable number b to stack
;      called from $1e2e
; ---------------------------------------------------------------------------

1806 : cd0e04 jsr $0e04           ; naechstes Byte (b) aus EEPROM holen
1809   b754   sta $54             ; auf $54 sichern
180b   9b     sei                 ;
180c   97     tax                 ; x = a
180d   5d     tstx                ;
180e   2724   beq $1834           ; ist b = #0 ? dann YEAR lesen
1810   5a     decx                ;
1811   2725   beq $1838           ; ist b = #1 ? dann MONTH lesen
1813   5a     decx                ;
1814   2726   beq $183c           ; ist b = #2 ? dann DAY lesen
1816   5a     decx                ;
1817   2727   beq $1840           ; ist b = #3 ? dann DOW lesen
1819   5a     decx                ;
181a   2728   beq $1844           ; ist b = #4 ? dann HOUR lesen
181c   5a     decx                ;
181d   2729   beq $1848           ; ist b = #5 ? dann MINUTE lesen
181f   5a     decx                ;
1820   272a   beq $184c           ; ist b = #6 ? dann SECOND lesen
1822   5a     decx                ;
1823   272e   beq $1853           ; ist b = #7 ? dann TIMER lesen
1825   5a     decx                ;
1826   5a     decx                ;
1827   2738   beq $1861           ; ist b = #9 ? dann FREQ1 lesen
1829   5a     decx                ;
182a   273a   beq $1866           ; ist b = #10 ? dann FREQ2 lesen
182c   5a     decx                ;
182d   273c   beq $186b           ; ist b = #11 ? dann FILEFREE lesen
182f   5a     decx                ;
1830   2742   beq $1874           ; ist b = #12 ? dann Anzahl der Bytes in
1832 : 9a     cli                 ;   der EEPROM-Datendatei lesen
1833   81     rts                 ; return from subroutine

1834 : be90   ldx $90             ; YEAR nach x
1836   2016   bra $184e           ; und springen

1838 : be82   ldx $82             ; MONTH nach x
183a   2012   bra $184e           ; und springen

183c : be6a   ldx $6a             ; DAY nach x
183e   200e   bra $184e           ; und springen

1840 : be6b   ldx $6b             ; DOW nach x
1842   200a   bra $184e           ; und springen

1844 : be80   ldx $80             ; HOUR nach x
1846   2006   bra $184e           ; und springen

1848 : be81   ldx $81             ; MINUTE nach x
184a   2002   bra $184e           ; und springen

184c : be89   ldx $89             ; SECOND nach x
184e : cd125c jsr $125c           ; x auf den Rechenstack pushen
1851   20df   bra $1832           ; beenden

1853 : 9b     sei                 ; zum Lesen die Interrupts verbieten
1854   cd1155 jsr $1155           ; a=lowbyte, x=highbyte des TIMERs
1857   b7d3   sta $d3             ; TIMER lowbyte nach $d3
1859   bfd2   stx $d2             ; TIMER highbyte nach $d2
185b   cd1267 jsr $1267           ; und auf Rechenstack pushen
185e   9a     cli                 ; Interrupts wieder erlauben
185f   20d1   bra $1832           ; beenden

1861 : cd115c jsr $115c           ; FREQ1 holen
1864   2008   bra $186e           ; und springen

1866 : cd1163 jsr $1163           ; FREQ2 holen
1869   2003   bra $186e           ; und springen

186b : cd1b0f jsr $1b0f           ; FILEFREE holen
186e : b7d3   sta $d3             ; lowbyte
1870   bfd2   stx $d2             ; highbyte
1872   2008   bra $187c           ; und springen

1874 : b6c8   lda $c8             ; Anzahl der Bytes in der EEPROM-Datendatei
1876   b7d2   sta $d2             ;   holen
1878   b6c9   lda $c9             ;
187a   b7d3   sta $d3             ;
187c : cd1267 jsr $1267           ; Word auf den Rechenstack pushen
187f   20b1   bra $1832           ; beenden

; ---------------------------------------------------------------------------
;      BASIC Token 29 b - internes BASIC-Kommando
;      store Top-Of-Stack to internal variable number b
;      called from $1e30
; ---------------------------------------------------------------------------

1881 : cd0e04 jsr $0e04           ; Hole naechstes Byte (b) vom EEPROM
1884   b754   sta $54             ; Akkumulator nach $54
1886   b691   lda $91             ;
1888   b7ce   sta $ce             ; Top-Of-Stack nach $ce:$cf retten
188a   b692   lda $92             ;
188c   b7cf   sta $cf             ; a = lowbyte von Top-Of-Stack
188e   9b     sei                 ;
188f   be54   ldx $54             ; x = $54
1891   2718   beq $18ab           ; ist b = #0 ? dann YEAR setzen
1893   5a     decx                ;
1894   2719   beq $18af           ; ist b = #1 ? dann MONTH setzen
1896   5a     decx                ;
1897   271a   beq $18b3           ; ist b = #2 ? dann DAY setzen
1899   5a     decx                ;
189a   271b   beq $18b7           ; ist b = #3 ? dann DOW setzen
189c   5a     decx                ;
189d   271c   beq $18bb           ; ist b = #4 ? dann HOUR setzen
189f   5a     decx                ;
18a0   271d   beq $18bf           ; ist b = #5 ? dann MINUTE setzen
18a2   5a     decx                ;
18a3   271e   beq $18c3           ; ist b = #6 ? dann SECOND setzen
18a5   5a     decx                ;
18a6   5a     decx                ;
18a7   271e   beq $18c7           ; ist b = #8 ? dann TICKS setzen
18a9 : 9a     cli                 ;
18aa   81     rts                 ; return from subroutine

18ab : b790   sta $90             ; lade YEAR mit a
18ad   20fa   bra $18a9           ; beenden

18af : b782   sta $82             ; lade MONTH mit a
18b1   20f6   bra $18a9           ; beenden

18b3 : b76a   sta $6a             ; lade DAY mit a
18b5   20f2   bra $18a9           ; beenden

18b7 : b76b   sta $6b             ; lade DOW mit a
18b9   20ee   bra $18a9           ; beenden

18bb : b780   sta $80             ; lade HOUR mit a
18bd   20ea   bra $18a9           ; beenden

18bf : b781   sta $81             ; lade MINUTE mit a
18c1   20e6   bra $18a9           ; beenden

18c3 : b789   sta $89             ; lade SECOND mit a
18c5   20e2   bra $18a9           ; beenden

18c7 : b6ce   lda $ce             ; TICKS setzen
18c9   b7d0   sta $d0             ;
18cb   b6cf   lda $cf             ;
18cd   b7d1   sta $d1             ;
18cf   cd111a jsr $111a           ;
18d2   20d5   bra $18a9           ; beenden

; ---------------------------------------------------------------------------
;      BASIC Token 30 - PRINT number
;      Word vom Stack holen, ASCII-kodieren und auf der RS232 ausgeben
;
;      input : $91:$92 = Word
;      output: -
;      used  : a,x,$11,$54-$59,$d0-$d1,$d9-$da,$dd-$df
;
;      called from $1e32
; ---------------------------------------------------------------------------

18d4 : b691   lda $91             ; load accu with value at address $91
18d6   b7d0   sta $d0             ; store accumulator at address $d0
18d8   b692   lda $92             ; load accu with value at address $92
18da   b7d1   sta $d1             ; store accumulator at address $d1
18dc   cc0ce8 jmp $0ce8           ; unconditional jump to address $0ce8

; ---------------------------------------------------------------------------
;      BASIC Token 31 s - PRINT string
;      nullterminierten String ausgeben
;      called from $1e34
; ---------------------------------------------------------------------------

18df : 2004   bra $18e5           ; branch always to $18e5

18e1 : 97     tax                 ; transfer accumulator to index register
18e2   cd0c77 jsr $0c77           ; jump to subroutine at address $0c77
18e5 : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
18e8   b7ce   sta $ce             ; store accumulator at address $ce
18ea   26f5   bne $18e1           ; branch if not equal (Z is clear)
18ec   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      BASIC Token 32 - PUT
;      Word (Byte) vom Stack holen und auf RS232 ausgeben
;
;      input : $92 = Byte
;      output: -
;      used  : x,$11
;
;      called from $1e36
; ---------------------------------------------------------------------------

18ed : be92   ldx $92             ; load index reg. with value at addr. $92
18ef   cc0c77 jmp $0c77           ; unconditional jump to address $0c77

; ---------------------------------------------------------------------------
;      BASIC Token 33 - RXD
;      falls ein Byte aus dem RS232-Buffer geholt werden kann, HIGH auf den
;      Stack pushen; sonst LOW
;
;      input : -
;      output: $91:$92 = -1 wenn Bedingung erfuellt, sonst 0
;      used  : a,x,$0(%01000000),$54,$91-$9e
;
;      called from $1e38
; ---------------------------------------------------------------------------

18f2 : cd0cce jsr $0cce           ; jump to subroutine at address $0cce
18f5   97     tax                 ; transfer accumulator to index register
18f6   cc1246 jmp $1246           ; unconditional jump to address $1246

; ---------------------------------------------------------------------------
;      BASIC Token 34 - GET
;      ein Byte von der RS232 holen und auf den Stack (als Word) pushen
;
;      input : -
;      output: $91:$92 = empfangenes Byte, bzw. Word
;      used  : a,x,$0(%01000000),$54,$63-$64,$91-$9e
;
;      called from $1e3a
; ---------------------------------------------------------------------------

18f9 : cd0cb5 jsr $0cb5           ; jump to subroutine at address $0cb5
18fc   97     tax                 ; transfer accumulator to index register
18fd   cc125c jmp $125c           ; unconditional jump to address $125c

; ---------------------------------------------------------------------------
;      BASIC Token 36 b - HANDSHAKE
;      Abfrage der RTS- & CTS-Leitungen erlauben / verbieten
;      called from $1e3e
; ---------------------------------------------------------------------------

1900 : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
1903   4d     tsta                ; test accumulator for negative or zero
1904   2703   beq $1909           ; branch if equal (Z is set)
1906   1e7b   bset #7,$7b         ; set bit #7 at memory address $7b
1908   81     rts                 ; return from subroutine

1909 : 1f7b   bclr #7,$7b         ; clear bit #7 at memory address $7b
190b   1d00   bclr #6,$00         ; clear bit #6 at memory address $00
190d   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      BASIC Token 37 - CTS
;      falls die CTS-Leitung aktiv ist HIGH, sonst LOW auf den Stack pushen
;
;      input : -
;      output: $91:$92 = -1 wenn Bedingung erfuellt, sonst 0
;      used  : a,x,$54,$91-$9e
;
;      called from $1e40
; ---------------------------------------------------------------------------

190e : cd0cd9 jsr $0cd9           ; jump to subroutine at address $0cd9
1911   97     tax                 ; transfer accumulator to index register
1912   cc1246 jmp $1246           ; unconditional jump to address $1246

; ---------------------------------------------------------------------------
;      BASIC Token 35 - INPUT
;      Zahl ASCII-kodiert mit Carriage Return als Endezeichen von der RS232
;      empfangen und auf den Stack pushen
;
;      input : -
;      output: $91:$92 = empfangenes Word
;      used  : a,x,$0(%01000000),$54-$59,$63-$64,$91-$9e,$ce-$d0,$d2-$d3,
;              $d9,$dd-$df
;
;      called from $1e3c
; ---------------------------------------------------------------------------

1915 : 3fcf   clr $cf             ; clear memory at address $cf
1917   3fd0   clr $d0             ; clear memory at address $d0
1919   3fce   clr $ce             ; clear memory at address $ce
191b : cd0cb5 jsr $0cb5           ; jump to subroutine at address $0cb5
191e   b7d9   sta $d9             ; store accumulator at address $d9
1920   a12d   cmp #$2d            ; compare accumulator with value #$2d
1922   2606   bne $192a           ; branch if not equal (Z is clear)
1924   a601   lda #$01            ; load accumulator with value #$01
1926   b7ce   sta $ce             ; store accumulator at address $ce
1928   2030   bra $195a           ; branch always to $195a

192a : a130   cmp #$30            ; compare accumulator with value #$30
192c   252c   blo $195a           ; branch if accu is lower (C is set)
192e   a139   cmp #$39            ; compare accumulator with value #$39
1930   2228   bhi $195a           ; branch if accu is higher (unsigned)
1932   3f56   clr $56             ; clear memory at address $56
1934   a60a   lda #$0a            ; load accumulator with value #$0a
1936   b757   sta $57             ; store accumulator at address $57
1938   ae00   ldx #$00            ; load index register with value #$00
193a   bfde   stx $de             ; store index register at address $de
193c   aecf   ldx #$cf            ; load index register with value #$cf
193e   bfdf   stx $df             ; store index register at address $df
1940   cd1bb0 jsr $1bb0           ; jump to subroutine at address $1bb0
1943   b6d9   lda $d9             ; load accu with value at address $d9
1945   abd0   add #$d0            ; add value #$d0 to accumulator
1947   b7df   sta $df             ; store accumulator at address $df
1949   4f     clra                ; clear accumulator
194a   a9ff   adc #$ff            ; add (with carry) value #$ff to accu
194c   b7de   sta $de             ; store accumulator at address $de
194e   b6d0   lda $d0             ; load accu with value at address $d0
1950   bbdf   add $df             ; add value at address $df to accumulator
1952   b7d0   sta $d0             ; store accumulator at address $d0
1954   b6cf   lda $cf             ; load accu with value at address $cf
1956   b9de   adc $de             ; add (with carry) value at address $de
1958   b7cf   sta $cf             ; store accumulator at address $cf
195a : b6d9   lda $d9             ; load accu with value at address $d9
195c   a10d   cmp #$0d            ; compare accumulator with value #$0d
195e   26bb   bne $191b           ; branch if not equal (Z is clear)
1960   3dce   tst $ce             ; test for negative or zero at address $ce
1962   270d   beq $1971           ; branch if equal (Z is set)
1964   becf   ldx $cf             ; load index reg. with value at addr. $cf
1966   b6d0   lda $d0             ; load accu with value at address $d0
1968   53     comx                ; inverse index register (one's complement)
1969   40     nega                ; negate accumulator (two's complement)
196a   2501   blo $196d           ; branch if accu is lower (C is set)
196c   5c     incx                ; increment index register
196d : b7d0   sta $d0             ; store accumulator at address $d0
196f   bfcf   stx $cf             ; store index register at address $cf
1971 : b6cf   lda $cf             ; load accu with value at address $cf
1973   b7d2   sta $d2             ; store accumulator at address $d2
1975   b6d0   lda $d0             ; load accu with value at address $d0
1977   b7d3   sta $d3             ; store accumulator at address $d3
1979   cc1267 jmp $1267           ; unconditional jump to address $1267

; ---------------------------------------------------------------------------
;      BASIC Token 70 b - Befehle zum Handling der EEPROM-Datendatei
;                  70 1 - OPEN# FOR READ
;                  70 2 - OPEN# FOR WRITE
;                  70 3 - OPEN# FOR APPEND
;                  70 4 - CLOSE#
;                  70 5 - PRINT#
;                  70 6 - INPUT#
;      called from $1e82
; ---------------------------------------------------------------------------

197c : cd0e04 jsr $0e04           ; Hole naechstes Byte (b) vom EEPROM
197f   b7ce   sta $ce             ; Akkumulator nach Adresse $ce
1981   b666   lda $66             ;
1983   b7cf   sta $cf             ; BASIC-PC nach $cf:$d0 retten
1985   b667   lda $67             ;
1987   b7d0   sta $d0             ;
1989   cd0e01 jsr $0e01           ; Sequentielles Lesen vom EEPROM beenden
198c   bece   ldx $ce             ; x = $ce
198e   5a     decx                ;
198f   271a   beq $19ab           ; ist b = #1 ? dann OPEN# FOR READ
1991   5a     decx                ;
1992   271c   beq $19b0           ; ist b = #2 ? dann OPEN# FOR WRITE
1994   5a     decx                ;
1995   271e   beq $19b5           ; ist b = #3 ? dann OPEN# FOR APPEND
1997   5a     decx                ;
1998   2720   beq $19ba           ; ist b = #4 ? dann CLOSE#
199a   5a     decx                ;
199b   2722   beq $19bf           ; ist b = #5 ? dann PRINT#
199d   5a     decx                ;
199e   272c   beq $19cc           ; ist b = #6 ? dann INPUT#

19a0 : b6cf   lda $cf             ; BASIC-PC wieder restaurieren und
19a2   b7d3   sta $d3             ; ins EEPROM uebertragen
19a4   b6d0   lda $d0             ;
19a6   b7d4   sta $d4             ;
19a8   cc0de5 jmp $0de5           ; beenden

19ab : cd1a24 jsr $1a24           ; OPEN# FOR READ
19ae   20f0   bra $19a0           ; und BASIC-PC wieder restaurieren

19b0 : cd1a48 jsr $1a48           ; OPEN# FOR WRITE
19b3   20eb   bra $19a0           ; und BASIC-PC wieder restaurieren

19b5 : cd1a69 jsr $1a69           ; OPEN# FOR APPEND
19b8   20e6   bra $19a0           ; und BASIC-PC wieder restaurieren

19ba : cd1a91 jsr $1a91           ; CLOSE#
19bd   20e1   bra $19a0           ; und BASIC-PC wieder restaurieren

19bf : b691   lda $91             ; PRINT# Top-Of-Stack
19c1   b7d1   sta $d1             ;
19c3   b692   lda $92             ;
19c5   b7d2   sta $d2             ;
19c7   cd1aa7 jsr $1aa7           ;
19ca   20d4   bra $19a0           ; und BASIC-PC wieder restaurieren

19cc : cd1ad4 jsr $1ad4           ; INPUT#
19cf   b7d3   sta $d3             ;
19d1   bfd2   stx $d2             ;
19d3   cd1267 jsr $1267           ; Word auf den Rechenstack pushen
19d6   20c8   bra $19a0           ; und BASIC-PC wieder restaurieren

; ---------------------------------------------------------------------------
;      BASIC Token 71 - EOF
;      falls das Ende der Datendatei erreicht ist HIGH, sonst LOW auf den
;      Stack pushen
;
;      input : -
;      output: $91:$92 = -1 falls Bedingung erfuellt, sonst 0
;      used  : a,x,$54,$91-$9e
;
;      called from $1e84
; ---------------------------------------------------------------------------

19d8 : cd1afe jsr $1afe           ; jump to subroutine at address $1afe
19db   97     tax                 ; transfer accumulator to index register
19dc   cc1246 jmp $1246           ; unconditional jump to address $1246

; ---------------------------------------------------------------------------
;      BASIC Token 72 b - BAUD
;      naechstes Byte aus EEPROM holen und als Baudrate setzen
;      called from $1e86
; ---------------------------------------------------------------------------

19df : cd0e04 jsr $0e04           ; jump to subroutine at address $0e04
19e2   97     tax                 ; transfer accumulator to index register
19e3   cc0c74 jmp $0c74           ; unconditional jump to address $0c74

; ---------------------------------------------------------------------------
;      BASIC Token 73 w - INTERRUPT
;      naechstes Word (die Adresse der BASIC-IRQ-Routine) aus EEPROM
;      holen und an Adresse $b9:$ba schreiben
;      called from $1e88
; ---------------------------------------------------------------------------

19e6 : cd0e0d jsr $0e0d           ; jump to subroutine at address $0e0d
19e9   b7ba   sta $ba             ; store accumulator at address $ba
19eb   bfb9   stx $b9             ; store index register at address $b9
19ed   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      wird von der BASIC-Interpreterschleife beim Detektieren eines IRQ-
;      Interrupts aufgerufen
;      setzt den BASIC-PC auf den Anfang der BASIC-IRQ-Interruptroutine,
;      sofern eine Routine definiert wurde
;
;      input : [$b9:$ba = EEPROM-Adresse der IRQ-Routine, oder 0]
;      output: [$bb:$bc = BASIC-PC vor Aufruf der IRQ-Routine]
;      used  : a,x,$0(%00000011),$4(%00000001),$66-$67,$bb-$bc,$d3-$d4,$e1
;
;      called from $090b
; ---------------------------------------------------------------------------

19ee : b6b9   lda $b9             ; wurde eine BASIC-IRQ-Routine definiert?
19f0   baba   ora $ba             ; wenn nein, dann beenden
19f2   2716   beq $1a0a           ;
19f4   b666   lda $66             ; BASIC-PC nach $bb:$bc retten
19f6   b7bb   sta $bb             ;
19f8   b667   lda $67             ;
19fa   b7bc   sta $bc             ;
19fc   cd0e01 jsr $0e01           ; und den BASIC-PC sowie den Pointer
19ff   b6b9   lda $b9             ; des externen EEPROMS auf die BASIC-IRQ-
1a01   b7d3   sta $d3             ; Routine setzen
1a03   b6ba   lda $ba             ;
1a05   b7d4   sta $d4             ;
1a07   cd0de5 jsr $0de5           ;
1a0a : 81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      BASIC Token 7 - RETURN INTERRUPT
;      nach dem Ausfuehren der IRQ-Routine den BASIC-PC restaurieren
;
;      input : [$bb:$bc = BASIC-PC vor Aufruf der IRQ-Routine, oder 0]
;      output: [$66:$67 = BASIC-PC auf den alten Wert, $bb:$bc = 0]
;      used  : a,x,$0(%00000011),$4(%00000001),$66-$67,$bb-$bc,$d3-$d4,$e1
;
;      called from $1e04
; ---------------------------------------------------------------------------

1a0b : b6bb   lda $bb             ; ist auf $bb:$bc ein alter BASIC-PC
1a0d   babc   ora $bc             ; gespeichert (siehe hierzu auch $19ee)
1a0f   2712   beq $1a23           ; wenn nein, dann beenden
1a11   cd0e01 jsr $0e01           ;
1a14   b6bb   lda $bb             ; setze den BASIC-PC, als auch den Pointer
1a16   b7d3   sta $d3             ; des externen EEPROMS, wieder so wie
1a18   b6bc   lda $bc             ; vor der Ausfuehrung der BASIC-IRQ-
1a1a   b7d4   sta $d4             ; Routine
1a1c   cd0de5 jsr $0de5           ;
1a1f   3fbb   clr $bb             ; loesche den Buffer fuer den BASIC-PC
1a21   3fbc   clr $bc             ;
1a23 : 81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer OPEN# FOR READ
;
;      input : -
;      output: $c8:$c9 = Anzahl der Bytes in der EEPROM-Datendatei
;              $ca:$cb = #0 = Aktuelle Leseposition in der Datendatei
;              $cc:$cd = EEPROM-Anfangsadresse der Datendatei
;      used  : a,x,$0(%00000011),$4(%00000001),$66-$67,$c8-$cd,$d3-$d4,$e1
;
;      called from $19ab,$1b2d
; ---------------------------------------------------------------------------

1a24 : 5f     clrx                ; Word von EEPROM-Adresse #0 holen
1a25   4f     clra                ; (die Laenge des BASIC-Programms)
1a26   b7d4   sta $d4             ;
1a28   bfd3   stx $d3             ;
1a2a   cd0de5 jsr $0de5           ;
1a2d   cd0e0d jsr $0e0d           ;
1a30   ab04   add #$04            ; zum Word die Zahl #4 addieren und an
1a32   b7cd   sta $cd             ; Adresse $cc:$cd speichern (ergibt die
1a34   9f     txa                 ;   Anfangsadresse der Datendatei)
1a35   a900   adc #$00            ;
1a37   b7cc   sta $cc             ;
1a39   cd0e0d jsr $0e0d           ; Word von EEPROM-Adresse #2 holen
1a3c   b7c9   sta $c9             ; (die Laenge der EEPROM-Datendatei)
1a3e   bfc8   stx $c8             ; und auf Adresse $c8:$c9 speichern
1a40   cd0e01 jsr $0e01           ; Sequentielles Lesen vom EEPROM beenden
1a43   3fca   clr $ca             ;
1a45   3fcb   clr $cb             ; $ca:$cb = #0
1a47   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer OPEN# FOR WRITE
;
;      input : -
;      output: $c8:$c9 = #0 = Anzahl der Bytes in der EEPROM-Datendatei
;              $ca:$cb = #0 = Aktuelle Schreibposition in der Datendatei
;              $cc:$cd = EEPROM-Anfangsadresse der Datendatei
;      used  : a,x,$0(%00000011),$4(%00000001),$66-$67,$c8-$cd,$d3-$d4,$e1
;
;      called from $19b0
; ---------------------------------------------------------------------------

1a48 : 5f     clrx                ; Word von EEPROM-Adresse #0 holen
1a49   4f     clra                ; (die Laenge des BASIC-Programms)
1a4a   b7d4   sta $d4             ;
1a4c   bfd3   stx $d3             ;
1a4e   cd0de5 jsr $0de5           ;
1a51   cd0e0d jsr $0e0d           ;
1a54   ab04   add #$04            ; zum Word die Zahl #4 addieren und an
1a56   b7cd   sta $cd             ; Adresse $cc:$cd speichern (ergibt die
1a58   9f     txa                 ;   Anfangsadresse der Datendatei)
1a59   a900   adc #$00            ;
1a5b   b7cc   sta $cc             ;
1a5d   cd0e01 jsr $0e01           ; Sequentielles Lesen vom EEPROM beenden
1a60   3fc8   clr $c8             ;
1a62   3fc9   clr $c9             ; $c8:$c9 = #0
1a64   3fca   clr $ca             ;
1a66   3fcb   clr $cb             ; $ca:$cb = #0
1a68   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer OPEN# FOR APPEND
;
;      input : -
;      output: $c8:$c9 = Anzahl der Bytes in der EEPROM-Datendatei
;              $ca:$cb = Aktuelle Schreibposition in der Datendatei
;              $cc:$cd = EEPROM-Anfangsadresse der Datendatei
;      used  : a,x,$0(%00000011),$4(%00000001),$66-$67,$c8-$cd,$d3-$d4,$e1
;
;      called from $19b5
; ---------------------------------------------------------------------------

1a69 : 5f     clrx                ; Word von EEPROM-Adresse #0 holen
1a6a   4f     clra                ; (die Laenge des BASIC-Programms)
1a6b   b7d4   sta $d4             ;
1a6d   bfd3   stx $d3             ;
1a6f   cd0de5 jsr $0de5           ;
1a72   cd0e0d jsr $0e0d           ;
1a75   ab04   add #$04            ; zum Word die Zahl #4 addieren und an
1a77   b7cd   sta $cd             ; Adresse $cc:$cd speichern (ergibt die
1a79   9f     txa                 ;   Anfangsadresse der Datendatei)
1a7a   a900   adc #$00            ;
1a7c   b7cc   sta $cc             ;
1a7e   cd0e0d jsr $0e0d           ; Word von EEPROM-Adresse #2 holen
1a81   b7c9   sta $c9             ; (die Laenge der EEPROM-Datendatei)
1a83   bfc8   stx $c8             ; und auf Adresse $c8:$c9 speichern
1a85   cd0e01 jsr $0e01           ; Sequentielles Lesen vom EEPROM beenden
1a88   b6c8   lda $c8             ;
1a8a   b7ca   sta $ca             ; $ca:$cb = $c8:$c9
1a8c   b6c9   lda $c9             ;
1a8e   b7cb   sta $cb             ;
1a90   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer CLOSE#
;      die EEPROM-Datendatei schliessen, indem der Zaehler fuer die
;      Groesse der Datei ins EEPROM gespeichert wird
;
;      input : $c8:$c9 = Anzahl der Bytes in der EEPROM-Datendatei
;      output: -
;      used  : a,x,$0(%00000011),$4(%00000001),$66-$67,$d3-$d6,$e1
;
;      called from $19ba
; ---------------------------------------------------------------------------

1a91 : 5f     clrx                ; $66:$67 = #$0002
1a92   a602   lda #$02            ;
1a94   b7d4   sta $d4             ;
1a96   bfd3   stx $d3             ;
1a98   cd0d89 jsr $0d89           ;
1a9b   b6c8   lda $c8             ; den Inhalt des Words $c8:$c9 auf der
1a9d   b7d3   sta $d3             ;   EEPROM-Adresse #$0002 speichern
1a9f   b6c9   lda $c9             ;
1aa1   b7d4   sta $d4             ;
1aa3   cc0db3 jmp $0db3           ; beenden

; ---------------------------------------------------------------------------
;      Unexplored byte
; ---------------------------------------------------------------------------

1aa6 : d1     db $d1              ; %11010001

; ---------------------------------------------------------------------------
;      fuer PRINT#
;      Word in die EEPROM-Datendatei speichern
;
;      input : $d1:$d2 = Word
;              $c8:$c9 = Anzahl der Bytes in der EEPROM-Datendatei
;              $ca:$cb = Aktuelle Schreibposition in der Datendatei
;              $cc:$cd = EEPROM-Anfangsadresse der Datendatei
;      output: $c8:$c9 und $ca:$cb um zwei inkrementiert
;      used  : a,x,$0(%00000011),$4(%00000001),$66-$67,$c8-$cb,$d3-$d6,$e1
;
;      called from $19c7
; ---------------------------------------------------------------------------

1aa7 : b6cd   lda $cd             ; $66:$67 = $cc:$cd + $ca:$cb
1aa9   bbcb   add $cb             ;
1aab   b7d4   sta $d4             ;
1aad   b6cc   lda $cc             ;
1aaf   b9ca   adc $ca             ;
1ab1   b7d3   sta $d3             ;
1ab3   cd0d89 jsr $0d89           ;
1ab6   b6d1   lda $d1             ; den Inhalt des Words $d1:$d2 auf der
1ab8   b7d3   sta $d3             ;   EEPROM-Adresse die in $66:$67 steht
1aba   b6d2   lda $d2             ;   speichern
1abc   b7d4   sta $d4             ;
1abe   cd0db3 jsr $0db3           ;
1ac1   b6cb   lda $cb             ; $ca:$cb = $ca:$cb + #2
1ac3   ab02   add #$02            ;
1ac5   b7cb   sta $cb             ;
1ac7   b6ca   lda $ca             ;
1ac9   a900   adc #$00            ;
1acb   b7ca   sta $ca             ;
1acd   b7c8   sta $c8             ; $c8:$c9 = $ca:$cb
1acf   b6cb   lda $cb             ;
1ad1   b7c9   sta $c9             ;
1ad3   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer INPUT#
;      Word aus der EEPROM-Datendatei lesen
;
;      input : $ca:$cb = Aktuelle Leseposition in der Datendatei
;              $cc:$cd = EEPROM-Anfangsadresse der Datendatei
;      output: Word (a = low-, x = highbyte), $ca:$cb um zwei inkrementiert
;      used  : a,x,$0(%00000011),$4(%00000001),$66-$67,$ca-$cb,$d1-$d4,$e1
;
;      called from $19cc
; ---------------------------------------------------------------------------

1ad4 : b6cd   lda $cd             ; Adresszaehler fuer sequentielle EEPROM-
1ad6   bbcb   add $cb             ;   zugriffe des Mikrokontrollers und des
1ad8   b7d4   sta $d4             ;   EEPROMs auf $cc:$cd + $ca:$cb setzen
1ada   b6cc   lda $cc             ;
1adc   b9ca   adc $ca             ;
1ade   b7d3   sta $d3             ;
1ae0   cd0de5 jsr $0de5           ;
1ae3   cd0e0d jsr $0e0d           ; ein Word aus dem EEPROM holen und nach
1ae6   b7d2   sta $d2             ;   $d1:$d2 speichern
1ae8   bfd1   stx $d1             ;
1aea   cd0e01 jsr $0e01           ; Sequentielles Lesen vom EEPROM beenden
1aed   b6cb   lda $cb             ;
1aef   ab02   add #$02            ; und den Zeiger fuer die Leseposition
1af1   b7cb   sta $cb             ;   um zwei inkrementieren
1af3   b6ca   lda $ca             ;
1af5   a900   adc #$00            ;
1af7   b7ca   sta $ca             ;
1af9   bed1   ldx $d1             ; gelesenes Word in x:a
1afb   b6d2   lda $d2             ;
1afd   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer EOF
;      feststellen, ob die EEPROM-Datendatei bis zum Ende gelesen wurde
;
;      input : $c8:$c9 = Anzahl der Bytes in der EEPROM-Datendatei
;              $ca:$cb = Aktuelle Leseposition in der Datendatei
;      output: a = TRUE, wenn Leseposition >= Anzahl; a = FALSE sonst
;      used  : a
;
;      called from $19d8
; ---------------------------------------------------------------------------

1afe : b6ca   lda $ca             ; falls $c8:$c9 kleiner/gleich $ca:$cb
1b00   b1c8   cmp $c8             ;
1b02   2604   bne $1b08           ;
1b04   b6cb   lda $cb             ;
1b06   b1c9   cmp $c9             ;
1b08 : 2503   blo $1b0d           ;
1b0a   a601   lda #$01            ; dann TRUE zurueckliefern
1b0c   81     rts                 ; return from subroutine

1b0d : 4f     clra                ; sonst FALSE zurueckliefern
1b0e   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      fuer FILEFREE
;      Anzahl der noch freien Words im EEPROM errechnen; diese Routine
;      liefert (wahrscheinlich aus Sicherheitsgruenden) einen etwas
;      zu kleinen Wert zurueck
;
;      input : $c8:$c9 = Anzahl der Bytes in der EEPROM-Datendatei
;              $cc:$cd = EEPROM-Anfangsadresse der Datendatei
;      output: Anzahl der freien Words im EEPROM (a=low-, x=highbyte)
;      used  : a,x,$de,$df
;
;      called from $186b
; ---------------------------------------------------------------------------

1b0f : a6f4   lda #$f4            ; $de:$df = #$1ff4 - $c8:$c9
1b11   b0c9   sub $c9             ; (eigentlich #$2000 statt #$1ff4)
1b13   b7df   sta $df             ;
1b15   a61f   lda #$1f            ;
1b17   b2c8   sbc $c8             ;
1b19   b7de   sta $de             ;
1b1b   b6df   lda $df             ; $de:$df = $de:$df - $cc:$cd
1b1d   b0cd   sub $cd             ;
1b1f   b7df   sta $df             ;
1b21   b6de   lda $de             ;
1b23   b2cc   sbc $cc             ;
1b25   b7de   sta $de             ;
1b27   97     tax                 ; x = a
1b28   b6df   lda $df             ; a = lowbyte
1b2a   54     lsrx                ; Division durch #2
1b2b   46     rora                ; x:a = Anzahl der freien Bytes im EEPROM
1b2c   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      RS232-Befehl ASCII-Code 13 - Word-Dump der Datendatei im externen,
;                                   seriellen EEPROM ueber RS232 ausgeben
;
;      Die Routine ist leicht buggy: Der Zaehler auf $ca:$cb wird zwar
;      abgefragt, aber nie inkrementiert, so dass die Bedingung zum
;      Beenden der Schleife nur dann erfuellt ist, wenn die Datei leer ist.
;      Ausserdem wird in Bytes statt in Words gezaehlt.
;
;      input : -
;      output: -
;      used  : a,x,$0(%00000011),$4(%00000001),$11,$54-$59,$66-$67,$c8-$cd,
;              $d0-$d1,$d3-$d4,$d9-$da,$dd-$df,$e1
;
;      jumped from $0ad0
; ---------------------------------------------------------------------------

1b2d : cd1a24 jsr $1a24           ; OPEN# FOR READ
1b30   b6c8   lda $c8             ;
1b32   b7d0   sta $d0             ;
1b34   b6c9   lda $c9             ; Anzahl der Bytes in der Datei
1b36   b7d1   sta $d1             ; ueber RS232 ASCII-kodiert ausgeben
1b38   cd0ce8 jsr $0ce8           ;
1b3b   ae0d   ldx #$0d            ; gefolgt von einem Return
1b3d   cd0c77 jsr $0c77           ;
1b40   b6cc   lda $cc             ; Counter fuer sequentielle EEPROM-
1b42   b7d3   sta $d3             ; Zugriffe im Mikrokontroller und im
1b44   b6cd   lda $cd             ; EEPROM auf erstes Word der Datei
1b46   b7d4   sta $d4             ; setzen
1b48   cd0de5 jsr $0de5           ;
1b4b   200f   bra $1b5c           ; springe zum Schleifenstart

1b4d : cd0e0d jsr $0e0d           ; Hole naechstes Word vom EEPROM
1b50   b7d1   sta $d1             ;
1b52   bfd0   stx $d0             ; Word auf RS232 ASCII-kodiert ausgeben
1b54   cd0ce8 jsr $0ce8           ;
1b57   ae0d   ldx #$0d            ; gefolgt von einem Return
1b59   cd0c77 jsr $0c77           ;
1b5c : b6ca   lda $ca             ; ist Zaehler kleiner als die Anzahl
1b5e   b1c8   cmp $c8             ; der Bytes im EEPROM?
1b60   2604   bne $1b66           ;
1b62   b6cb   lda $cb             ;
1b64   b1c9   cmp $c9             ; dann mache weiter
1b66 : 25e5   blo $1b4d           ;
1b68   cc0e01 jmp $0e01           ; Seq. Lesen vom EEPROM beenden & rts

; ---------------------------------------------------------------------------
;      Vergleiche zwei Worte miteinander und setze die Flags
;      (testen ob erstes Word <, >, =, <>, <= oder >= zweites Word)
;
;      input : $54:$55 = erstes Word, $56:$57 = zweites Word
;      output: FLAGS (Z,N,C)
;      used  : a
;
;      called from $0bf9,$0d27,$1494,$14b4,$14d4,$14fa,$1520,$1546
; ---------------------------------------------------------------------------

1b6b : b654   lda $54             ; load accu with value at address $54
1b6d   b056   sub $56             ; subtract value at address $56 from accu
1b6f   270c   beq $1b7d           ; branch if equal (Z is set)
1b71 : 46     rora                ; rotate accumulator right through carry
1b72   b854   eor $54             ; XOR accu with value at address $54
1b74   b856   eor $56             ; XOR accu with value at address $56
1b76   98     clc                 ; clear carry bit
1b77   aa01   ora #$01            ; OR accumulator with value #$01
1b79   2a01   bpl $1b7c           ; branch if plus (N bit is clear)
1b7b   99     sec                 ; set carry bit
1b7c : 81     rts                 ; return from subroutine

1b7d : b655   lda $55             ; load accu with value at address $55
1b7f   b057   sub $57             ; subtract value at address $57 from accu
1b81   26ee   bne $1b71           ; branch if not equal (Z is clear)
1b83   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Multipliziere zwei Worte miteinander
;
;      input : $54:$55 = erstes Word, $56:$57 = zweites Word
;      output: $54:$55 = Ergebnis
;      used  : a,$54-$59
;
;      called from $1370,$1bb3
; ---------------------------------------------------------------------------

1b84 : b654   lda $54             ; load accu with value at address $54
1b86   b758   sta $58             ; store accumulator at address $58
1b88   b655   lda $55             ; load accu with value at address $55
1b8a   b759   sta $59             ; store accumulator at address $59
1b8c   3f54   clr $54             ; clear memory at address $54
1b8e   3f55   clr $55             ; clear memory at address $55
1b90   2004   bra $1b96           ; branch always to $1b96

1b92 : 3857   lsl $57             ; shift left at address $57
1b94   3956   rol $56             ; rotate left through carry at address $56
1b96 : 01590c brclr #0,$59,$1ba5  ; branch to $1ba5 if bit #0 at $59 is clear
1b99   b657   lda $57             ; load accu with value at address $57
1b9b   bb55   add $55             ; add value at address $55 to accumulator
1b9d   b755   sta $55             ; store accumulator at address $55
1b9f   b656   lda $56             ; load accu with value at address $56
1ba1   b954   adc $54             ; add (with carry) value at address $54
1ba3   b754   sta $54             ; store accumulator at address $54
1ba5 : 3458   lsr $58             ; logical shift right at address $58
1ba7   3659   ror $59             ; rotate right through carry at address $59
1ba9   26e7   bne $1b92           ; branch if not equal (Z is clear)
1bab   3d58   tst $58             ; test for negative or zero at address $58
1bad   26e3   bne $1b92           ; branch if not equal (Z is clear)
1baf   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Word1, dessen Adresse auf $de:$df steht, mit Word2 in $56:$57
;      multiplizieren und Ergebnis in Word1 zurueckliefern
;
;      input : $de:$df = Adresse von Word1, $56:$57 = Word2
;      output: Word1 = Word1 * Word2
;      used  : a,$54-$59,$dd-$df
;
;      called from $1476,$1940
; ---------------------------------------------------------------------------

1bb0 : cd1ca2 jsr $1ca2           ; jump to subroutine at address $1ca2
1bb3   cd1b84 jsr $1b84           ; jump to subroutine at address $1b84
1bb6   cc1cb5 jmp $1cb5           ; unconditional jump to address $1cb5

; ---------------------------------------------------------------------------
;      Dividiere Word1 vorzeichenlos durch Word2 und liefere das
;      Divisionsergebnis und den Modulowert zurueck
;
;      input : $54:$55 = Word1, $56:$57 = Word2
;      output: $54:$55 = Modulo-Wert, $58:$59 = Ergebnis
;      used  : a,x,$54-$59
;
;      called from $1c0f,$1c40,$1c51,$1c66,$1c77,$1c8f
; ---------------------------------------------------------------------------

1bb9 : b656   lda $56             ; load accu with value at address $56
1bbb   ba57   ora $57             ; OR accu with value at address $57
1bbd   2607   bne $1bc6           ; branch if not equal (Z is clear)
1bbf   4f     clra                ; clear accumulator
1bc0 : 5f     clrx                ; clear index register
1bc1   b758   sta $58             ; store accumulator at address $58
1bc3   bf59   stx $59             ; store index register at address $59
1bc5   81     rts                 ; return from subroutine

1bc6 : b654   lda $54             ; load accu with value at address $54
1bc8   ba55   ora $55             ; OR accu with value at address $55
1bca   27f4   beq $1bc0           ; branch if equal (Z is set)
1bcc   5f     clrx                ; clear index register
1bcd   bf58   stx $58             ; store index register at address $58
1bcf   bf59   stx $59             ; store index register at address $59
1bd1   2010   bra $1be3           ; branch always to $1be3

1bd3 : b654   lda $54             ; load accu with value at address $54
1bd5   b156   cmp $56             ; compare accu with value at address $56
1bd7   2604   bne $1bdd           ; branch if not equal (Z is clear)
1bd9   b655   lda $55             ; load accu with value at address $55
1bdb   b157   cmp $57             ; compare accu with value at address $57
1bdd : 2308   bls $1be7           ; branch if accu is lower or same (unsigned)
1bdf   3857   lsl $57             ; shift left at address $57
1be1   3956   rol $56             ; rotate left through carry at address $56
1be3 : 5c     incx                ; increment index register
1be4   0f56ec brclr #7,$56,$1bd3  ; branch to $1bd3 if bit #7 at $56 is clear
1be7 : b654   lda $54             ; load accu with value at address $54
1be9   b156   cmp $56             ; compare accu with value at address $56
1beb   2604   bne $1bf1           ; branch if not equal (Z is clear)
1bed   b655   lda $55             ; load accu with value at address $55
1bef   b157   cmp $57             ; compare accu with value at address $57
1bf1 : 250f   blo $1c02           ; branch if accu is lower (C is set)
1bf3   b655   lda $55             ; load accu with value at address $55
1bf5   b057   sub $57             ; subtract value at address $57 from accu
1bf7   b755   sta $55             ; store accumulator at address $55
1bf9   b654   lda $54             ; load accu with value at address $54
1bfb   b256   sbc $56             ; subtract (with carry) value at addr. $56
1bfd   b754   sta $54             ; store accumulator at address $54
1bff   99     sec                 ; set carry bit
1c00   2001   bra $1c03           ; branch always to $1c03

1c02 : 98     clc                 ; clear carry bit
1c03 : 3959   rol $59             ; rotate left through carry at address $59
1c05   3958   rol $58             ; rotate left through carry at address $58
1c07   3456   lsr $56             ; logical shift right at address $56
1c09   3657   ror $57             ; rotate right through carry at address $57
1c0b   5a     decx                ; decrement index register
1c0c   26d9   bne $1be7           ; branch if not equal (Z is clear)
1c0e   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Dividiere Word1 vorzeichenlos durch Word2
;
;      input : $54:$55 = Word1, $56:$57 = Word2
;      output: $54:$55 = Ergebnis
;      used  : a,x,$54-$59
;
;      called from $1c7d
; ---------------------------------------------------------------------------

1c0f : ada8   bsr $1bb9           ; branch to subroutine at address $1bb9
1c11   b658   lda $58             ; load accu with value at address $58
1c13   b754   sta $54             ; store accumulator at address $54
1c15   b659   lda $59             ; load accu with value at address $59
1c17   b755   sta $55             ; store accumulator at address $55
1c19   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Vorzeichenbehaftete Zahlen in vorzeichenlose umwandeln (fuer
;      vorzeichenlose Division), diese Routine enthaelt einen Bug
;
;      Fehlerfrei arbeitet diese Routine nur, wenn Word1 Werte im
;      Bereich von -32767 bis 32767 und Word2 Werte im Bereich von
;      0 bis 32767 annimmt.
;
;      Wenn Word2 vorzeichenbehaftet ist, wird es trotzdem nicht
;      invertiert. Ein spezieller Fehler tritt auf wenn Word1=-32768
;      ist. Dann wird das Word auf Adresse $55:$56 invertiert, also
;      sowohl Teile von Word1 und Word2!
;
;      input : $54:$55 = Word1, $56:$57 = Word2
;      output: $54:$55 und $56:$57 enthalten u.U. ein falsches Ergebnis
;      used  : a,$54,$55,$56
;
;      called from $1c3d,$1c4e,$1c63,$1c74
; ---------------------------------------------------------------------------

1c1a : b654   lda $54             ; ist Word1 positiv?
1c1c   2a0a   bpl $1c28           ; falls ja, springe
1c1e   4f     clra                ;
1c1f   b055   sub $55             ;
1c21   b755   sta $55             ; falls nein, invertiere
1c23   4f     clra                ;   Word1
1c24   b254   sbc $54             ;
1c26   b754   sta $54             ;

1c28 : b654   lda $54             ; hier muss "lda $56" stehen
1c2a   2a0a   bpl $1c36           ;
1c2c   4f     clra                ;
1c2d   b056   sub $56             ; hier muss "sub $57" stehen
1c2f   b756   sta $56             ; hier muss "sta $57" stehen
1c31   4f     clra                ;
1c32   b255   sbc $55             ; hier muss "sbc $56" stehen
1c34   b755   sta $55             ; hier muss "sta $56" stehen
1c36 : 81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Dividiere Word1 durch Word2
;
;      input : $54:$55 = Word1, $56:$57 = Word2
;      output: $54:$55 = Ergebnis
;      used  : a,x,$54-$59
;
;      called from $0d47,$138e,$1411,$1426,$1c86
; ---------------------------------------------------------------------------

1c37 : b654   lda $54             ; haben die beiden Woerter das gleiche
1c39   b856   eor $56             ; Vorzeichen?
1c3b   2a11   bpl $1c4e           ; falls ja, springe
1c3d   cd1c1a jsr $1c1a           ; Vorzeichen anpassen
1c40   cd1bb9 jsr $1bb9           ; Haupt-Divisionsroutine
1c43   4f     clra                ;
1c44   b059   sub $59             ;
1c46   b755   sta $55             ; Ergebnis invertieren und
1c48   4f     clra                ; auf $54:$55 schreiben
1c49   b258   sbc $58             ;
1c4b   b754   sta $54             ;
1c4d   81     rts                 ; return from subroutine

1c4e : cd1c1a jsr $1c1a           ; Vorzeichen anpassen
1c51   cd1bb9 jsr $1bb9           ; Haupt-Divisionsroutine
1c54   b659   lda $59             ;
1c56   b755   sta $55             ; Ergebnis auf $54:$55 schreiben
1c58   b658   lda $58             ;
1c5a   b754   sta $54             ;
1c5c   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Dividiere Word1 durch Word2 und liefere Modulo-Wert zurueck
;
;      input : $54:$55 = Word1, $56:$57 = Word2
;      output: $54:$55 = Ergebnis
;      used  : a,x,$54-$59
;
;      called from $13ac,$1c98
; ---------------------------------------------------------------------------

1c5d : b654   lda $54             ; haben die beiden Woerter das gleiche
1c5f   b856   eor $56             ; Vorzeichen?
1c61   2a11   bpl $1c74           ; falls ja, springe

1c63   cd1c1a jsr $1c1a           ; Vorzeichen anpassen
1c66   cd1bb9 jsr $1bb9           ; Haupt-Divisionsroutine
1c69   4f     clra                ;
1c6a   b055   sub $55             ; Ergebnis invertieren und auf
1c6c   b755   sta $55             ; $54:$55 schreiben
1c6e   4f     clra                ;
1c6f   b254   sbc $54             ;
1c71   b754   sta $54             ;
1c73   81     rts                 ; return from subroutine

1c74 : cd1c1a jsr $1c1a           ; Vorzeichen anpassen
1c77   cc1bb9 jmp $1bb9           ; Haupt-Divisionsroutine

; ---------------------------------------------------------------------------
;      Word1, dessen Adresse in $de:$df steht, durch Word2 in $56:$57
;      teilen und Ergebnis in Word1 zurueckliefern
;      (vorzeichenlose Division)
;
;      input : $de:$df = Adresse von Word1, $56:$57 = Word2
;      output: Word1 = Word1 \ Word2
;      used  : a,x,$54-$59,$dd-$df
;
;      never called
; ---------------------------------------------------------------------------

1c7a : cd1ca2 jsr $1ca2           ; jump to subroutine at address $1ca2
1c7d   cd1c0f jsr $1c0f           ; jump to subroutine at address $1c0f
1c80   cc1cb5 jmp $1cb5           ; unconditional jump to address $1cb5

; ---------------------------------------------------------------------------
;      Word1, dessen Adresse in $de:$df steht, durch Word2 in $56:$57
;      teilen und Ergebnis in Word1 zurueckliefern
;
;      input : $de:$df = Adresse von Word1, $56:$57 = Word2
;      output: Word1 = Word1 \ Word2
;      used  : a,x,$54-$59,$dd-$df
;
;      never called
; ---------------------------------------------------------------------------

1c83 : cd1ca2 jsr $1ca2           ; jump to subroutine at address $1ca2
1c86   cd1c37 jsr $1c37           ; jump to subroutine at address $1c37
1c89   cc1cb5 jmp $1cb5           ; unconditional jump to address $1cb5

; ---------------------------------------------------------------------------
;      Word1, dessen Adresse in $de:$df steht, durch Word2 in $56:$57
;      teilen und Modulo-Wert in Word1 zurueckliefern
;      (vorzeichenlose Division)
;
;      input : $de:$df = Adresse von Word1, $56:$57 = Word2
;      output: Word1 = Word1 MOD Word2
;      used  : a,x,$54-$59,$dd-$df
;
;      never called
; ---------------------------------------------------------------------------

1c8c : cd1ca2 jsr $1ca2           ; jump to subroutine at address $1ca2
1c8f   cd1bb9 jsr $1bb9           ; jump to subroutine at address $1bb9
1c92   cc1cb5 jmp $1cb5           ; unconditional jump to address $1cb5

; ---------------------------------------------------------------------------
;      Word1, dessen Adresse in $de:$df steht, durch Word2 in $56:$57
;      teilen und Modulo-Wert in Word1 zurueckliefern
;
;      input : $de:$df = Adresse von Word1, $56:$57 = Word2
;      output: Word1 = Word1 MOD Word2
;      used  : a,x,$54-$59,$dd-$df
;
;      called from $0d7c
; ---------------------------------------------------------------------------

1c95 : cd1ca2 jsr $1ca2           ; jump to subroutine at address $1ca2
1c98   cd1c5d jsr $1c5d           ; jump to subroutine at address $1c5d
1c9b   cc1cb5 jmp $1cb5           ; unconditional jump to address $1cb5

; ---------------------------------------------------------------------------
;      Inhalt (Word) einer ueber einen 16-Bit-Zeiger adressierten
;      Speicherstelle holen ('lda adr16', 'sta $54', 'lda adr16+1'
;      und 'sta $55' simulieren)
;
;      input : x=highbyte, a=lowbyte der 16-Bit-Adresse
;      output: $54:$55 = Inhalt (Word) von adr16, $de:$df = adr16+1
;      used  : a,$54,$55,$dd,$de,$df
;
;      never called
; ---------------------------------------------------------------------------

1c9e : bfde   stx $de             ; store index register at address $de
1ca0   b7df   sta $df             ; store accumulator at address $df

; ---------------------------------------------------------------------------
;      Inhalt (Word) einer ueber einen 16-Bit-Zeiger adressierten
;      Speicherstelle holen ('lda adr16', 'sta $54', 'lda adr16+1'
;      und 'sta $55' simulieren)
;
;      input : $de=highbyte, $df=lowbyte der 16-Bit-Adresse
;      output: $54:$55 = Inhalt (Word) von adr16, $de:$df inkrementiert
;      used  : a,$54,$55,$dd,$de,$df
;
;      called from $1bb0,$1c7a,$1c83,$1c8c,$1c95
; ---------------------------------------------------------------------------

1ca2 : a6c6   lda #$c6            ; load accumulator with value #$c6
1ca4   b7dd   sta $dd             ; store accumulator at address $dd
1ca6   bddd   jsr $dd             ; jump to subroutine at address $dd
1ca8   b754   sta $54             ; store accumulator at address $54
1caa   3cdf   inc $df             ; increment at address $df
1cac   2602   bne $1cb0           ; branch if not equal (Z is clear)
1cae   3cde   inc $de             ; increment at address $de
1cb0 : bddd   jsr $dd             ; jump to subroutine at address $dd
1cb2   b755   sta $55             ; store accumulator at address $55
1cb4   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Word auf einer 16-Bit-Adresse speichern
;      ('lda $55', 'sta adr16', 'lda $54' und 'sta adr16-1' simulieren)
;
;      input : $de=highbyte, $df=lowbyte der 16-Bit-Adresse
;              $54=highbyte, $55=lowbyte des zu schreibenden Words
;      output: adr16-1=Inhalt (Word) von $54:$55, $de:$df dekrementiert
;      used  : a,$dd,$de,$df
;
;      jumped from $1bb6,$1c80,$1c89,$1c92,$1c9b
; ---------------------------------------------------------------------------

1cb5 : a6c7   lda #$c7            ; load accumulator with value #$c7
1cb7   b7dd   sta $dd             ; store accumulator at address $dd
1cb9   b655   lda $55             ; load accu with value at address $55
1cbb   bddd   jsr $dd             ; jump to subroutine at address $dd
1cbd   3ddf   tst $df             ; test for negative or zero at address $df
1cbf   2602   bne $1cc3           ; branch if not equal (Z is clear)
1cc1   3ade   dec $de             ; decrement at address $de
1cc3 : 3adf   dec $df             ; decrement at address $df
1cc5   b654   lda $54             ; load accu with value at address $54
1cc7   bcdd   jmp $dd             ; unconditional jump to address $dd

; ---------------------------------------------------------------------------
;      Inhalt (Word) einer ueber einen 16-Bit-Zeiger adressierten
;      Speicherstelle holen ('lda adr16', 'sta ,x', 'lda adr16+1' und
;      'sta $01,x' simulieren)
;
;      input : $de=highbyte, $df=lowbyte der 16-Bit-Adresse,
;              x=Zieladresse
;      output: auf x:x+1 steht das Word von adr16, $de:$df inkrementiert
;      used  : a,$dd,$de,$df
;
;      called from $0d1c,$0d3c,$0d71
; ---------------------------------------------------------------------------

1cc9 : a6c6   lda #$c6            ; load accumulator with value #$c6
1ccb   b7dd   sta $dd             ; store accumulator at address $dd
1ccd   bddd   jsr $dd             ; jump to subroutine at address $dd
1ccf   f7     sta ,x              ; store accumulator at address in x-regist.
1cd0   3cdf   inc $df             ; increment at address $df
1cd2   2602   bne $1cd6           ; branch if not equal (Z is clear)
1cd4   3cde   inc $de             ; increment at address $de
1cd6 : bddd   jsr $dd             ; jump to subroutine at address $dd
1cd8   e701   sta $01,x           ; store accumulator at address $01 + x-reg.
1cda   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      Sprung zu einer 16-Bit-Adresse ('jmp adr16' simulieren)
;      wird aufgerufen, nachdem $1ce3 abgearbeitet wurde
;
;      input : $de=highbyte, $df=lowbyte der 16-Bit-Adresse
;      output: -
;      used  : $dd
;
;      called from $093b
; ---------------------------------------------------------------------------

1cdb : 11dd   bclr #0,$dd         ; clear bit #0 at memory address $dd
1cdd   13dd   bclr #1,$dd         ; clear bit #1 at memory address $dd
1cdf   16dd   bset #3,$dd         ; set bit #3 at memory address $dd
1ce1   bcdd   jmp $dd             ; unconditional jump to address $dd

; ---------------------------------------------------------------------------
;      Inhalt (Word) einer ueber einen 16-Bit-Zeiger adressierten
;      Speicherstelle holen ('lda adr16' und 'ldx adr16+1' simulieren)
;
;      input : a=lowbyte, x=highbyte der 16-Bit-Adresse
;      output: a=Inhalt von adr16, x=Inhalt von adr16+1
;      used  : a,x,$dd,$de,$df
;
;      called from $0938
; ---------------------------------------------------------------------------

1ce3 : bfde   stx $de             ; store index register at address $de
1ce5   b7df   sta $df             ; store accumulator at address $df
1ce7   a6c6   lda #$c6            ; load accumulator with value #$c6
1ce9   b7dd   sta $dd             ; store accumulator at address $dd
1ceb   bddd   jsr $dd             ; jump to subroutine at address $dd
1ced   3cdf   inc $df             ; increment at address $df
1cef   2602   bne $1cf3           ; branch if not equal (Z is clear)
1cf1   3cde   inc $de             ; increment at address $de
1cf3 : 16dd   bset #3,$dd         ; set bit #3 at memory address $dd
1cf5   bddd   jsr $dd             ; jump to subroutine at address $dd
1cf7   b7de   sta $de             ; store accumulator at address $de
1cf9   bfdf   stx $df             ; store index register at address $df
1cfb   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      'ldx adr16' simulieren
;
;      input : a=lowbyte, x=highbyte der 16-Bit-Adresse
;      output: x=Inhalt von adr16
;      used  : x,$dd,$de,$df
;
;      called from $0bdf
; ---------------------------------------------------------------------------

1cfc : bfde   stx $de             ; store index register at address $de
1cfe   b7df   sta $df             ; store accumulator at address $df
1d00   aece   ldx #$ce            ; load index register with value #$ce
1d02   bfdd   stx $dd             ; store index register at address $dd
1d04   bcdd   jmp $dd             ; unconditional jump to address $dd

; ---------------------------------------------------------------------------
;      Initialisierung der Pseudo-Adressierungscodes ('lda adr16' und
;      'rts' auf Adresse $dd setzen)
;
;      input : -
;      output: -
;      used  : a,$dd,$e0
;
;      called from $080b
; ---------------------------------------------------------------------------

1d06 : cc1d09 jmp $1d09           ; unconditional jump to address $1d09
1d09 : a6c6   lda #$c6            ; load accumulator with value #$c6
1d0b   b7dd   sta $dd             ; store accumulator at address $dd
1d0d   a681   lda #$81            ; load accumulator with value #$81
1d0f   b7e0   sta $e0             ; store accumulator at address $e0
1d11   81     rts                 ; return from subroutine

; ---------------------------------------------------------------------------
;      wird bei jedem RESET aufgerufen, initialisiert den Mikrokontroller
;      und das Betriebssystem und startet die IDLE-LOOP (siehe $969)
;
;      used  : a,x,$0(%01011111),$4(%01011111),$7(%00000111),$9(%00100000),
;              $c(%00100000),$d-$f,$11,$12(%11000001),$50-$5a,$63-$7b,
;              $7b(%11010011),$7c-$82,$85-$9e,$b9-$d4,$d9-$da,$dd,
;              $dd(%00001011),$de-$e1
;
;      jumped from $1ffe (RESET)
; ---------------------------------------------------------------------------

1d12 : cc0800 jmp $0800           ; unbedingter Sprung zur Adresse $0800

; ---------------------------------------------------------------------------
;      wird bei jedem Timer Overflow Interrupt aufgerufen
;
;      Immer wenn der interne Zeitzaehler im Timer Counter Register (TR)
;      von #$ffff auf #$0000 springt wird dieser Interrupt ausgeloest.
;      Das passiert alle 65536*4 Taktzyklen (etwa alle 0.13 Sekunden im
;      normalen, und alle 2.1 Sekunden im SLOWMODE).
;
;      Um das Timer Overflow Flag (TOF) zu loeschen muss TR_LOW und TSR
;      gelesen werden.
;
;      used  : a,x
;
;      called from $1ff4 (TIMEROFL)
; ---------------------------------------------------------------------------

1d15 : b653   lda $53             ; ist CAPPTR belegt?
1d17   2708   beq $1d21           ; falls nein, normales Handling
1d19   97     tax                 ; User-Maschinencoderoutine fuer
1d1a   dd0100 jsr $0100,x         ;   TIMEROFL aufrufen
1d1d   a100   cmp #$00            ; wenn die Routine den Akku geloescht hat,
1d1f   2704   beq $1d25           ;   Betriebssystembefehle ueberspringen
1d21 : b613   lda $13             ; TSR laden
1d23   b619   lda $19             ; TR_LOW laden
1d25 : 80     rti                 ; return from interrupt

; ---------------------------------------------------------------------------
;      wird bei jedem IRQ Interrupt aufgerufen
;
;      Der External Interrupt kann durch die Verbindung des IRQ-Eingangs
;      mit Masse ausgeloest werden und dient zum Aufrufen von User-
;      Interruptroutinen, die wahlweise in BASIC und/oder Assembler
;      programmiert werden koennen.
;
;      used  : a,x,$7b(%01000000)
;
;      called from $1ffa (IRQ)
; ---------------------------------------------------------------------------

1d26 : b650   lda $50             ; ist IRQPTR belegt?
1d28   2708   beq $1d32           ; falls nein, IRQ an BASIC melden
1d2a   97     tax                 ; User-Maschinencoderoutine fuer
1d2b   dd0100 jsr $0100,x         ;   IRQ aufrufen
1d2e   a100   cmp #$00            ; falls von der Routine der Akku geloescht
1d30   27f3   beq $1d25           ;   wurde, IRQ nicht mehr an BASIC melden
1d32 : 1c7b   bset #6,$7b         ; BASIC-IRQ-Routine soll aufgerufen werden
1d34   80     rti                 ; return from interrupt

; ---------------------------------------------------------------------------
;      wird bei jedem Timer Input Capture 1 und 2 Interrupt aufgerufen
;
;      Der DCF77-Empfaenger haengt am TCAP1-Pin des Mikrokontrollers und
;      generiert deshalb einen Input Capture 1-Interrupt.
;      Mit IEDG1 (input edge sensitivity) kann das Programm bestimmen, ob
;      der Interrupt in Zukunft bei einer positiven (IEDG1 gesetzt) oder
;      bei einer negativen Flanke (IEDG1 geloescht) ausgeloest werden soll.
;
;      Am TCAP2-Pin kann eine andere Signalquelle angeschlossen werden,
;      deren Frequenz ueber die Systemvariable FREQ2 abgefragt werden kann.
;      Dieser Eingang reagiert aber nur auf negative Flanken.
;
;      Nachdem das Highbyte eines Input capture registers (ICR1 oder ICR2)
;      gelesen wurde, wird es solange nicht veraendert bis das Lowbyte
;      ebenfalls gelesen wird. Aus diesem Grund wird aus ICR1_LOW und
;      ICR2_LOW am Ende der Interruptroutine vorsichtshalber gelesen.
;
;      used  : a,x,$0(%00010000),$12(%00000010),$6a-$7a,$7b(%00010001),
;              $80-$82,$85-$89,$90,$e2
;
;      called from $1ff8 (TIMERCAP)
; ---------------------------------------------------------------------------

1d35 : b651   lda $51             ; ist CAPPTR belegt?
1d37   2708   beq $1d41           ; falls nein, normale Routine aufrufen
1d39   97     tax                 ; User-Maschinencoderoutine fuer
1d3a   dd0100 jsr $0100,x         ;   TIMERCAP aufrufen
1d3d   a100   cmp #$00            ; wenn die Routine den Akku geloescht hat,
1d3f   27e4   beq $1d25           ;   Betriebssystemroutine nicht aufrufen
1d41 : 0e1309 brset #7,$13,$1d4d  ; springe, wenn ICF1 gesetzt ist (DCF77)
1d44   3c88   inc $88             ;
1d46   2602   bne $1d4a           ; Buffer fuer FREQ2 inkrementieren
1d48   3c87   inc $87             ;
1d4a : b61d   lda $1d             ; Akku mit ICR2_LOW laden
1d4c   80     rti                 ; return from interrupt

1d4d : 031207 brclr #1,$12,$1d57  ; springe, wenn IEDG1 geloescht ist
1d50   1312   bclr #1,$12         ; IEDG1 loeschen
1d52   cd0f0d jsr $0f0d           ; Routine DCF77_HIGH aufrufen
1d55   2005   bra $1d5c           ; springen

1d57 : 1212   bset #1,$12         ; IEDG1 setzen
1d59   cd0f45 jsr $0f45           ; Routine DCF77_LOW aufrufen
1d5c : b615   lda $15             ; Akku mit ICR1_LOW laden
1d5e   80     rti                 ; return from interrupt

; ---------------------------------------------------------------------------
;      wird bei jedem Timer Output Compare 1 und 2 Interrupt aufgerufen
;
;      Der Timer Output Compare 2 Interrupt spielt im Mikrokontroller eine
;      wichtige Rolle. Er wird standardmaessig alle 20 ms ausgeloest und
;      zaehlt z.B. die Uhr und die TIMER-Systemvariable weiter und
;      generiert die PAUSE-Verzoegerung und das TEST-Signal (am TCMP2-Pin).
;
;      Der Timer Output Compare 1 Interrupt dient zum Generieren des Ton-
;      signals am BEEP-Ausgang (TCMP1-Pin). Dessen Ausloesehaeufigkeit
;      wird vom CCBASIC-Interpreter je nach gewuenschter Ausgangsfrequenz
;      veraendert.
;
;      used  : a,x,$0(%00010000),$12(%00000101),$16-$17,$1e-$1f,$68-$6b,
;              $6d-$6e,$7b(%00000001),$7c-$8b,$8e-$90,$e3-$e4
;
;      called from $1ff6 (TIMERCMP)
; ---------------------------------------------------------------------------

1d5f : b652   lda $52             ; ist CMPPTR belegt?
1d61   2708   beq $1d6b           ; falls nein, normale Routine aufrufen
1d63   97     tax                 ; User-Maschinencoderoutine fuer
1d64   dd0100 jsr $0100,x         ;   TIMERCMP aufrufen
1d67   a100   cmp #$00            ; wenn die Routine den Akku geloescht hat,
1d69   27ba   beq $1d25           ;   Betriebssystemroutine nicht aufrufen
1d6b : 0d1304 brclr #6,$13,$1d72  ; springe, wenn OCF1 geloescht ist
1d6e   cd0ee9 jsr $0ee9           ; Routine TIMERCMP1 aufrufen
1d71   80     rti                 ; return from interrupt

1d72 : cd0e70 jsr $0e70           ; Routine TIMERCMP2 aufrufen
1d75   80     rti                 ; return from interrupt

; ---------------------------------------------------------------------------
;      EINSCHALTMELDUNG, COPYRIGHT
; ---------------------------------------------------------------------------

1d76 :        db "CCTRL-BASIC Version 1.1 (20.12.96)",0
              db "(C) 1996, Conrad Electronic GmbH Germany",0
              db "Martin Foerster, CTC",0

; ---------------------------------------------------------------------------
;      TABELLE (wird von der Routine $0ce8 benutzt)
;      zum Kodieren einer Zahl in den ASCII-Dezimalcode
; ---------------------------------------------------------------------------

1dd7 :        dw 10000,1000,100,10,1

; ---------------------------------------------------------------------------
;      TABELLE (wird von der Routine $106a benutzt)
;      enthaelt die Anzahl der Tage jeden Monats (Monat=Offset von 1..12)
; ---------------------------------------------------------------------------

1de1 :        db 0,31,28,31,30,31,30,31,31,30,31,30,31

; ---------------------------------------------------------------------------
;      TABELLE (wird von der Routine $0fce benutzt)
;      zum Dekodieren einer DCF77-Highmarke
; ---------------------------------------------------------------------------

1dee :        db 1,2,4,8,10,20,40,80

; ---------------------------------------------------------------------------
;      SPRUNGTABELLE (wird von der Routine $08ee benutzt)
;      die Anfangsadressen der Hauptroutinen der verschiedenen BASIC-Token
; ---------------------------------------------------------------------------

1df6 :        dw $15b7,$15b8,$15bb,$15cb,$15e0,$169d,$16a6,$1a0b,$170a,$1714
              dw $1720,$172b,$1736,$1740,$174b,$1756,$1761,$176f,$15b7,$15b7
              dw $1796,$17a0,$17a7,$17ae,$17b5,$17bc,$17c3,$17ca,$1806,$1881
              dw $18d4,$18df,$18ed,$18f2,$18f9,$1915,$1900,$190e,$15b7,$15b7
              dw $12b6,$12c3,$12d2,$12d6,$12e5,$12e9,$12f8,$1316,$1442,$1468
              dw $1334,$1342,$1351,$1360,$137e,$139c,$13ba,$13e8,$1484,$14a4
              dw $14c4,$1510,$14ea,$1536,$155c,$1579,$13cc,$15b7,$15b7,$15b7
              dw $197c,$19d8,$19df,$19e6,$161f,$1628,$1631,$1640,$15b7,$15b7
              dw $177a,$1781,$1788,$178f,$0a82

; ---------------------------------------------------------------------------
;      Der Bereich von Adresse $1ea0 bis $1eff haette von Conrad Electronic
;      belegt werden koennen, ist aber leer.
; ---------------------------------------------------------------------------

              org $1fe2

; ***************************************************************************
; **                                                                       **
; **   Self-Check-ROM II                                                   **
; **                                                                       **
; **   Im Bereich von Adresse $1f00 bis $1ff1 liegt bei jedem MC68HC05B6   **
; **   das sogenannte "Self-Check ROM II", das bis auf untenstehende       **
; **   Tabelle leer ist.                                                   **
; **                                                                       **
; ***************************************************************************

; ---------------------------------------------------------------------------
;      TABELLE (enthaelt vermutlich Sprungadressen, nicht fuer CCBASIC)
; ---------------------------------------------------------------------------

1fe2 : 0054   dw $0054            ; %0000000001010100
1fe4 : 0054   dw $0054            ; %0000000001010100
1fe6 : 0054   dw $0054            ; %0000000001010100
1fe8 : 0054   dw $0054            ; %0000000001010100
1fea : 0054   dw $0054            ; %0000000001010100
1fec : 0054   dw $0054            ; %0000000001010100
1fee : 0200   dw $0200            ; jump to Self check ROM I (?)
1ff0 : 0068   dw $0068            ; %0000000001101000

; ***************************************************************************
; **                                                                       **
; **   INTERRUPTTABELLE                                                    **
; **                                                                       **
; **   Sie enthaelt die Startadressen der verschiedenen Routinen, die bei  **
; **   einem Interrupt aufgerufen werden                                   **
; **                                                                       **
; ***************************************************************************

1ff2 : 0c7d   dw $0c7d            ; Serial communications interface (SCI)
1ff4 : 1d15   dw $1d15            ; Timer overflow (TIMEROFL)
1ff6 : 1d5f   dw $1d5f            ; Timer output compare 1 & 2 (TIMERCMP)
1ff8 : 1d35   dw $1d35            ; Timer input capture 1 & 2 (TIMERCAP)
1ffa : 1d26   dw $1d26            ; External IRQ (IRQ)
1ffc : 0000   dw $0000            ; SWI wird nicht verwendet
1ffe : 1d12   dw $1d12            ; Reset/power-on reset (RESET)

; ***************************************************************************
; **                                                                       **
; **   ENDE DES ROMS                                                       **
; **                                                                       **
; ***************************************************************************


; ---------------------------------------------------------------------------
; Diese Datei gehoert zur Informationssammlung "C-Control intern" von Dietmar
; Harlos zum C-Control-Mikrokontrollersystem. Die Fehlerfreiheit der Angaben
; kann nicht garantiert werden. Die kommerzielle Nutzung irgendeiner Informa-
; tion oder eines Verfahrens dieser Sammlung ist ausdruecklich untersagt!
; Eine aktuelle Version dieser Sammlung kann als ZIP-Archiv im Internet unter
; der Adresse "http://www.geocities.com/ccontrolintern" heruntergeladen werden.
; Weitere Informationen zum Copyright entnehmen Sie bitte der Datei INFO.TXT.
; ---------------------------------------------------------------------------

